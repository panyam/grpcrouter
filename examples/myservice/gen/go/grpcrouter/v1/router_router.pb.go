// Code generated by protoc-gen-grpcrouter. DO NOT EDIT.
// source: grpcrouter/v1/router.proto

package grpcrouterv1

import (
	"context"
	"io"
	"log"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/anypb"

	"github.com/panyam/grpcrouter/router"
	pb "github.com/panyam/grpcrouter/proto/gen/go/grpcrouter/v1"
)

// RouterRouter implements Router interface with routing capabilities
type RouterRouter struct {
	correlator *router.RequestCorrelator
	registry   *router.ServiceRegistry
	config     *router.RouterConfig
}

// NewRouterRouter creates a new Router router
func NewRouterRouter(config *router.RouterConfig) *RouterRouter {
	if config == nil {
		config = &router.RouterConfig{
			DefaultTimeout:      30 * time.Second,
			MaxConcurrentRPCs:   1000,
			HealthCheckInterval: 30 * time.Second,
		}
	}
	return &RouterRouter{
		correlator: router.NewRequestCorrelator(),
		registry:   router.NewServiceRegistry(),
		config:     config,
	}
}

// Register handles service instance registration
func (r *RouterRouter) Register(stream pb.Router_RegisterServer) error {
	// Use the generic router server logic
	routerServer := router.NewRouterServer(r.config)
	return routerServer.Register(stream)
}

// Register implements the Register method with routing
func (r *RouterRouter) Register(stream Router_RegisterServer) error {
	// Read first message to establish routing
	firstMsg, err := stream.Recv()
	if err != nil {
		return err
	}

	// Extract routing key
	routingKey := r.extractRoutingKey(stream.Context(), firstMsg)

	// Convert first message to Any
	firstAny, err := anypb.New(firstMsg)
	if err != nil {
		return status.Errorf(codes.Internal, "failed to marshal request: %v", err)
	}

	// Route the call
	call, err := r.routeRPC(stream.Context(), "Router", "/Router/Register", pb.RpcMethodType_BIDIRECTIONAL_STREAMING, firstAny, routingKey)
	if err != nil {
		return err
	}

	// Handle bidirectional streaming
	errChan := make(chan error, 2)

	// Goroutine to handle client -> server streaming
	go func() {
		defer r.sendStreamControl(call.RequestID, pb.StreamControl_HALF_CLOSE)
		for {
			msg, err := stream.Recv()
			if err == io.EOF {
				errChan <- nil
				return
			}
			if err != nil {
				errChan <- err
				return
			}

			msgAny, err := anypb.New(msg)
			if err != nil {
				errChan <- err
				return
			}

			if err := r.sendStreamMessage(call.RequestID, msgAny, pb.StreamControl_MESSAGE); err != nil {
				errChan <- err
				return
			}
		}
	}()

	// Goroutine to handle server -> client streaming
	go func() {
		for {
			select {
			case streamMsg := <-call.StreamChan:
				if streamMsg == nil {
					errChan <- nil
					return
				}
				var resp RegisterResponse
				if err := streamMsg.Message.UnmarshalTo(&resp); err != nil {
					errChan <- err
					return
				}
				if err := stream.Send(&resp); err != nil {
					errChan <- err
					return
				}
			case err := <-call.ErrorChan:
				errChan <- err
				return
			case <-call.Context.Done():
				errChan <- call.Context.Err()
				return
			}
		}
	}()

	// Wait for completion
	return <-errChan
}

// HealthCheck implements the HealthCheck method with routing
func (r *RouterRouter) HealthCheck(ctx context.Context, req *HealthCheckRequest) (*HealthCheckResponse, error) {
	// Extract routing key from metadata or request
	routingKey := r.extractRoutingKey(ctx, req)

	// Convert request to Any
	reqAny, err := anypb.New(req)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "failed to marshal request: %v", err)
	}

	// Route the call
	call, err := r.routeRPC(ctx, "Router", "/Router/HealthCheck", pb.RpcMethodType_UNARY, reqAny, routingKey)
	if err != nil {
		return nil, err
	}

	// Wait for response
	select {
	case respAny := <-call.ResponseChan:
		var resp HealthCheckResponse
		if err := respAny.UnmarshalTo(&resp); err != nil {
			return nil, status.Errorf(codes.Internal, "failed to unmarshal response: %v", err)
		}
		return &resp, nil
	case err := <-call.ErrorChan:
		return nil, err
	case <-call.Context.Done():
		return nil, call.Context.Err()
	}
}

// ListInstances implements the ListInstances method with routing
func (r *RouterRouter) ListInstances(ctx context.Context, req *ListInstancesRequest) (*ListInstancesResponse, error) {
	// Extract routing key from metadata or request
	routingKey := r.extractRoutingKey(ctx, req)

	// Convert request to Any
	reqAny, err := anypb.New(req)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "failed to marshal request: %v", err)
	}

	// Route the call
	call, err := r.routeRPC(ctx, "Router", "/Router/ListInstances", pb.RpcMethodType_UNARY, reqAny, routingKey)
	if err != nil {
		return nil, err
	}

	// Wait for response
	select {
	case respAny := <-call.ResponseChan:
		var resp ListInstancesResponse
		if err := respAny.UnmarshalTo(&resp); err != nil {
			return nil, status.Errorf(codes.Internal, "failed to unmarshal response: %v", err)
		}
		return &resp, nil
	case err := <-call.ErrorChan:
		return nil, err
	case <-call.Context.Done():
		return nil, call.Context.Err()
	}
}

// extractRoutingKey extracts the routing key from context or request
func (r *RouterRouter) extractRoutingKey(ctx context.Context, req interface{}) string {
	// TODO: Implement routing key extraction based on routing strategy
	// For now, extract from gRPC metadata
	if md, ok := metadata.FromIncomingContext(ctx); ok {
		if values := md.Get("instanceid"); len(values) > 0 {
			return values[0]
		}
	}
	return ""
}

// routeRPC routes an RPC call to an appropriate service instance
func (r *RouterRouter) routeRPC(ctx context.Context, serviceName, method string, methodType pb.RpcMethodType, request *anypb.Any, routingKey string) (*router.PendingCall, error) {
	// Create a generic router server to handle the routing
	routerServer := router.NewRouterServer(r.config)
	return routerServer.RouteRPC(ctx, serviceName, method, methodType, request, nil, routingKey)
}

// sendStreamMessage sends a stream message for an active RPC call
func (r *RouterRouter) sendStreamMessage(requestID string, message *anypb.Any, control pb.StreamControl) error {
	routerServer := router.NewRouterServer(r.config)
	return routerServer.SendStreamMessage(requestID, message, control)
}

// sendStreamControl sends a stream control signal
func (r *RouterRouter) sendStreamControl(requestID string, control pb.StreamControl) error {
	return r.sendStreamMessage(requestID, nil, control)
}
