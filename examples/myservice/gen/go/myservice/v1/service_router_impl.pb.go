// Code generated by protoc-gen-grpcrouter. DO NOT EDIT.
// source: myservice/v1/service_router.proto

package v1

import (
	"context"
	"log"
	"strconv"
	"sync"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"

	"github.com/panyam/grpcrouter/router"
	pb "github.com/panyam/grpcrouter/proto/gen/go/grpcrouter/v1"
)

// MyServiceRouterImpl implements MyServiceRouterServer with routing capabilities
type MyServiceRouterImpl struct {
	UnimplementedMyServiceRouterServer

	// Core routing components
	correlator *router.RequestCorrelator
	registry   *router.ServiceRegistry
	config     *router.RouterConfig

	// Service instance management
	instances    map[string]*router.ServiceInstance
	instancesMux sync.RWMutex
}

// NewMyServiceRouterImpl creates a new MyService router
func NewMyServiceRouterImpl(config *router.RouterConfig) *MyServiceRouterImpl {
	if config == nil {
		config = &router.RouterConfig{
			DefaultTimeout:      30 * time.Second,
			MaxConcurrentRPCs:   1000,
			HealthCheckInterval: 30 * time.Second,
		}
	}
	return &MyServiceRouterImpl{
		correlator: router.NewRequestCorrelator(),
		registry:   router.NewServiceRegistry(),
		config:     config,
		instances:  make(map[string]*router.ServiceInstance),
	}
}

// Method1 implements the Method1 method with routing
func (r *MyServiceRouterImpl) Method1(ctx context.Context, req *Method1Request) (*Method1Response, error) {
	// Extract routing key from metadata or request
	routingKey := r.extractRoutingKey(ctx, req)

	// Find appropriate instance
	instance, err := r.registry.SelectInstance("MyService", routingKey)
	if err != nil {
		return nil, status.Errorf(codes.Unavailable, "no available instance for service MyService: %v", err)
	}

	// Create typed RPC call
	call := &MyServiceRpcCall{
		RequestId:  "req-" + strconv.FormatInt(time.Now().UnixNano(), 10),
		Method:     "/MyService/Method1",
		MethodType: pb.RpcMethodType_UNARY,
		Metadata:   make(map[string]string),
		Request:    &MyServiceRpcCall_Method1{Method1: req},
	}

	// Send typed call to instance and wait for typed response
	response, err := r.sendTypedCall(instance, call)
	if err != nil {
		return nil, err
	}

	// Extract typed response
	if resp := response.GetMethod1(); resp != nil {
		return resp, nil
	}

	return nil, status.Errorf(codes.Internal, "invalid response type for Method1")
}

// Method2 implements the Method2 method with routing
func (r *MyServiceRouterImpl) Method2(req *Method2Request, stream MyServiceRouter_Method2Server) error {
	// Extract routing key from metadata or request
	routingKey := r.extractRoutingKey(stream.Context(), req)

	// Find appropriate instance
	instance, err := r.registry.SelectInstance("MyService", routingKey)
	if err != nil {
		return status.Errorf(codes.Unavailable, "no available instance for service MyService: %v", err)
	}

	// Create typed RPC call
	call := &MyServiceRpcCall{
		RequestId:  "req-" + strconv.FormatInt(time.Now().UnixNano(), 10),
		Method:     "/MyService/Method2",
		MethodType: pb.RpcMethodType_SERVER_STREAMING,
		Metadata:   make(map[string]string),
		Request:    &MyServiceRpcCall_Method2{Method2: req},
	}

	// For server streaming, establish streaming connection and forward responses
	return r.handleServerStreamingCall(instance, call, stream)
}

// Method3 implements the Method3 method with routing
func (r *MyServiceRouterImpl) Method3(stream MyServiceRouter_Method3Server) error {
	// For client streaming, we need to read the first message to determine routing
	// Extract routing key from stream context
	routingKey := r.extractRoutingKey(stream.Context(), nil)

	// Find appropriate instance
	instance, err := r.registry.SelectInstance("MyService", routingKey)
	if err != nil {
		return status.Errorf(codes.Unavailable, "no available instance for service MyService: %v", err)
	}

	// For client streaming, establish bidirectional stream and forward all messages
	return r.handleClientStreamingCall(instance, stream)
}

// StreamMethod implements the StreamMethod method with routing
func (r *MyServiceRouterImpl) StreamMethod(stream MyServiceRouter_StreamMethodServer) error {
	// For bidirectional streaming, extract routing key from stream context
	routingKey := r.extractRoutingKey(stream.Context(), nil)

	// Find appropriate instance
	instance, err := r.registry.SelectInstance("MyService", routingKey)
	if err != nil {
		return status.Errorf(codes.Unavailable, "no available instance for service MyService: %v", err)
	}

	// For bidirectional streaming, establish full duplex connection
	return r.handleBidirectionalStreamingCall(instance, stream)
}

// Register handles service instance registration with typed messages
func (r *MyServiceRouterImpl) Register(stream MyServiceRouter_RegisterServer) error {
	// Wait for initial registration message
	req, err := stream.Recv()
	if err != nil {
		return status.Errorf(codes.Internal, "failed to receive registration: %v", err)
	}

	// Extract instance info
	instanceInfo := req.GetInstanceInfo()
	if instanceInfo == nil {
		return status.Errorf(codes.InvalidArgument, "expected instance info in first message")
	}

	// Validate service name
	if instanceInfo.ServiceName != "MyService" {
		return status.Errorf(codes.InvalidArgument, "service name mismatch: expected MyService, got %s", instanceInfo.ServiceName)
	}

	// Create service instance
	instance := &router.ServiceInstance{
		InstanceID:    instanceInfo.InstanceId,
		ServiceName:   "MyService",
		Endpoint:      instanceInfo.Endpoint,
		Metadata:      instanceInfo.Metadata,
		HealthStatus:  instanceInfo.HealthStatus,
		RegisteredAt:  time.Now(),
		LastHeartbeat: time.Now(),
		RequestQueue:  make(chan *pb.RpcCall, 100),
		ResponseQueue: make(chan *pb.RpcResponse, 100),
		Connected:     true,
	}

	// Register instance
	r.instancesMux.Lock()
	r.instances[instanceInfo.InstanceId] = instance
	r.instancesMux.Unlock()

	if err := r.registry.RegisterInstance(instance); err != nil {
		r.instancesMux.Lock()
		delete(r.instances, instanceInfo.InstanceId)
		r.instancesMux.Unlock()
		return status.Errorf(codes.AlreadyExists, "failed to register instance: %v", err)
	}

	// Send registration acknowledgment
	ack := &MyServiceRegisterResponse{
		Response: &MyServiceRegisterResponse_Ack{
			Ack: &pb.RegistrationAck{
				InstanceId: instanceInfo.InstanceId,
				Success:    true,
				Message:    "Registration successful",
			},
		},
	}

	if err := stream.Send(ack); err != nil {
		r.unregisterInstance(instanceInfo.InstanceId)
		return status.Errorf(codes.Internal, "failed to send acknowledgment: %v", err)
	}

	log.Printf("Service instance registered: %s (MyService)", instanceInfo.InstanceId)

	// Start instance handling goroutines
	go r.handleInstanceRequests(instance)
	go r.handleInstanceResponses(instance)

	// Handle incoming messages from the instance
	return r.handleInstanceMessages(instance)
}

// extractRoutingKey extracts the routing key from context or request
func (r *MyServiceRouterImpl) extractRoutingKey(ctx context.Context, req interface{}) string {
	// Strategy 1: Extract from gRPC metadata (primary)
	if md, ok := metadata.FromIncomingContext(ctx); ok {
		// Check common routing key metadata fields
		if values := md.Get("instanceid"); len(values) > 0 {
			return values[0]
		}
		if values := md.Get("routing-key"); len(values) > 0 {
			return values[0]
		}
		if values := md.Get("service-instance"); len(values) > 0 {
			return values[0]
		}
	}

	// Strategy 2: Default routing (round-robin)
	// If no routing key specified, use empty string for default selection
	return ""
}

// sendTypedCall sends a typed RPC call to an instance and waits for typed response
func (r *MyServiceRouterImpl) sendTypedCall(instance *router.ServiceInstance, call *MyServiceRpcCall) (*MyServiceRpcResponse, error) {
	// For now, return placeholder error until full implementation
	// The correct implementation requires:
	// 1. Fixing stream type compatibility between typed and generic streams
	// 2. Using CreatePendingCall from correlator with proper method signature
	// 3. Implementing typed response correlation

	_ = instance // Avoid unused variable warning
	_ = call     // Avoid unused variable warning

	return nil, status.Errorf(codes.Unimplemented, "typed call routing requires stream type compatibility fixes")
}

// unregisterInstance removes an instance from the router
func (r *MyServiceRouterImpl) unregisterInstance(instanceID string) {
	r.instancesMux.Lock()
	delete(r.instances, instanceID)
	r.instancesMux.Unlock()
	r.registry.UnregisterInstance(instanceID)
}

// handleInstanceMessages processes incoming messages from a service instance
func (r *MyServiceRouterImpl) handleInstanceMessages(instance *router.ServiceInstance) error {
	// This method would handle ongoing communication with service instances
	// For now, the Register method handles the initial registration stream
	// This method is called but immediately returns until stream types are aligned

	_ = instance // Avoid unused variable warning

	// TODO: Implement once stream type compatibility is resolved
	// This would handle:
	// 1. Incoming RPC responses from service instances
	// 2. Heartbeat messages and health status updates
	// 3. Instance disconnection and reconnection

	return status.Errorf(codes.Unimplemented, "instance message handling needs stream type fixes")
}

// handleInstanceRequests sends RPC requests to the service instance
func (r *MyServiceRouterImpl) handleInstanceRequests(instance *router.ServiceInstance) {
	// TODO: Implement instance request handling
}

// handleInstanceResponses processes RPC responses from the service instance
func (r *MyServiceRouterImpl) handleInstanceResponses(instance *router.ServiceInstance) {
	// TODO: Implement instance response handling
}

// handleServerStreamingCall handles server streaming RPC routing
func (r *MyServiceRouterImpl) handleServerStreamingCall(instance *router.ServiceInstance, call *MyServiceRpcCall, stream interface{}) error {
	// For server streaming, we need to establish streaming connection with service instance
	// This requires coordinating the stream between client and service instance
	_ = instance // Avoid unused variable warning
	_ = call     // Avoid unused variable warning
	_ = stream   // Avoid unused variable warning

	// For now, return error until full streaming infrastructure is implemented
	return status.Errorf(codes.Unimplemented, "server streaming routing requires full streaming infrastructure")
}

// handleClientStreamingCall handles client streaming RPC routing
func (r *MyServiceRouterImpl) handleClientStreamingCall(instance *router.ServiceInstance, stream interface{}) error {
	_ = instance // Avoid unused variable warning
	_ = stream   // Avoid unused variable warning
	// For now, return error until full streaming infrastructure is implemented
	return status.Errorf(codes.Unimplemented, "client streaming routing requires full streaming infrastructure")
}

// handleBidirectionalStreamingCall handles bidirectional streaming RPC routing
func (r *MyServiceRouterImpl) handleBidirectionalStreamingCall(instance *router.ServiceInstance, stream interface{}) error {
	_ = instance // Avoid unused variable warning
	_ = stream   // Avoid unused variable warning
	// For now, return error until full streaming infrastructure is implemented
	return status.Errorf(codes.Unimplemented, "bidirectional streaming routing requires full streaming infrastructure")
}
