// Code generated by protoc-gen-grpcrouter. DO NOT EDIT.
// source: myservice/v1/service.proto

package myservicev1

import (
	"context"
	"io"
	"log"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/anypb"

	"github.com/panyam/grpcrouter/router"
	pb "github.com/panyam/grpcrouter/proto/gen/go/grpcrouter/v1"
)

// MyServiceRouter implements MyService interface with routing capabilities
type MyServiceRouter struct {
	UnimplementedMyServiceServer
	correlator   *router.RequestCorrelator
	registry     *router.ServiceRegistry
	config       *router.RouterConfig
	routerServer *router.RouterServer
}

// NewMyServiceRouter creates a new MyService router
func NewMyServiceRouter(config *router.RouterConfig) *MyServiceRouter {
	if config == nil {
		config = &router.RouterConfig{
			DefaultTimeout:      30 * time.Second,
			MaxConcurrentRPCs:   1000,
			HealthCheckInterval: 30 * time.Second,
		}
	}
	routerServer := router.NewRouterServer(config)
	return &MyServiceRouter{
		correlator:   router.NewRequestCorrelator(),
		registry:     router.NewServiceRegistry(),
		config:       config,
		routerServer: routerServer,
	}
}

// Register handles service instance registration
func (r *MyServiceRouter) Register(stream pb.Router_RegisterServer) error {
	// Use the shared router server logic
	return r.routerServer.Register(stream)
}

// Method1 implements the Method1 method with routing
func (r *MyServiceRouter) Method1(ctx context.Context, req *Method1Request) (*Method1Response, error) {
	// Extract routing key from metadata or request
	routingKey := r.extractRoutingKey(ctx, req)

	// Convert request to Any
	reqAny, err := anypb.New(req)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "failed to marshal request: %v", err)
	}

	// Route the call
	call, err := r.routeRPC(ctx, "MyService", "/MyService/Method1", pb.RpcMethodType_UNARY, reqAny, routingKey)
	if err != nil {
		return nil, err
	}

	// Wait for response
	select {
	case respAny := <-call.ResponseChan:
		var resp Method1Response
		if err := respAny.UnmarshalTo(&resp); err != nil {
			return nil, status.Errorf(codes.Internal, "failed to unmarshal response: %v", err)
		}
		return &resp, nil
	case err := <-call.ErrorChan:
		return nil, err
	case <-call.Context.Done():
		return nil, call.Context.Err()
	}
}

// Method2 implements the Method2 method with routing
func (r *MyServiceRouter) Method2(req *Method2Request, stream MyService_Method2Server) error {
	// Extract routing key
	routingKey := r.extractRoutingKey(stream.Context(), req)

	// Convert request to Any
	reqAny, err := anypb.New(req)
	if err != nil {
		return status.Errorf(codes.Internal, "failed to marshal request: %v", err)
	}

	// Route the call
	call, err := r.routeRPC(stream.Context(), "MyService", "/MyService/Method2", pb.RpcMethodType_SERVER_STREAMING, reqAny, routingKey)
	if err != nil {
		return err
	}

	// Stream responses back to client
	for {
		select {
		case streamMsg := <-call.StreamChan:
			if streamMsg == nil {
				return nil // Stream closed
			}
			var resp Method2Response
			if err := streamMsg.Message.UnmarshalTo(&resp); err != nil {
				return status.Errorf(codes.Internal, "failed to unmarshal response: %v", err)
			}
			if err := stream.Send(&resp); err != nil {
				return err
			}
		case err := <-call.ErrorChan:
			return err
		case <-call.Context.Done():
			return call.Context.Err()
		}
	}
}

// Method3 implements the Method3 method with routing
func (r *MyServiceRouter) Method3(stream MyService_Method3Server) error {
	// Read first message to establish routing
	firstMsg, err := stream.Recv()
	if err != nil {
		return err
	}

	// Extract routing key
	routingKey := r.extractRoutingKey(stream.Context(), firstMsg)

	// Convert first message to Any
	firstAny, err := anypb.New(firstMsg)
	if err != nil {
		return status.Errorf(codes.Internal, "failed to marshal request: %v", err)
	}

	// Route the call
	call, err := r.routeRPC(stream.Context(), "MyService", "/MyService/Method3", pb.RpcMethodType_CLIENT_STREAMING, firstAny, routingKey)
	if err != nil {
		return err
	}

	// Stream remaining messages
	go func() {
		defer r.sendStreamControl(call.RequestID, pb.StreamControl_HALF_CLOSE)
		for {
			msg, err := stream.Recv()
			if err == io.EOF {
				return
			}
			if err != nil {
				log.Printf("Stream receive error: %v", err)
				return
			}

			msgAny, err := anypb.New(msg)
			if err != nil {
				log.Printf("Failed to marshal stream message: %v", err)
				return
			}

			if err := r.sendStreamMessage(call.RequestID, msgAny, pb.StreamControl_MESSAGE); err != nil {
				log.Printf("Failed to send stream message: %v", err)
				return
			}
		}
	}()

	// Wait for final response
	select {
	case respAny := <-call.ResponseChan:
		var resp Method3Response
		if err := respAny.UnmarshalTo(&resp); err != nil {
			return status.Errorf(codes.Internal, "failed to unmarshal response: %v", err)
		}
		return stream.SendAndClose(&resp)
	case err := <-call.ErrorChan:
		return err
	case <-call.Context.Done():
		return call.Context.Err()
	}
}

// StreamMethod implements the StreamMethod method with routing
func (r *MyServiceRouter) StreamMethod(stream MyService_StreamMethodServer) error {
	// Read first message to establish routing
	firstMsg, err := stream.Recv()
	if err != nil {
		return err
	}

	// Extract routing key
	routingKey := r.extractRoutingKey(stream.Context(), firstMsg)

	// Convert first message to Any
	firstAny, err := anypb.New(firstMsg)
	if err != nil {
		return status.Errorf(codes.Internal, "failed to marshal request: %v", err)
	}

	// Route the call
	call, err := r.routeRPC(stream.Context(), "MyService", "/MyService/StreamMethod", pb.RpcMethodType_BIDIRECTIONAL_STREAMING, firstAny, routingKey)
	if err != nil {
		return err
	}

	// Handle bidirectional streaming
	errChan := make(chan error, 2)

	// Goroutine to handle client -> server streaming
	go func() {
		defer r.sendStreamControl(call.RequestID, pb.StreamControl_HALF_CLOSE)
		for {
			msg, err := stream.Recv()
			if err == io.EOF {
				errChan <- nil
				return
			}
			if err != nil {
				errChan <- err
				return
			}

			msgAny, err := anypb.New(msg)
			if err != nil {
				errChan <- err
				return
			}

			if err := r.sendStreamMessage(call.RequestID, msgAny, pb.StreamControl_MESSAGE); err != nil {
				errChan <- err
				return
			}
		}
	}()

	// Goroutine to handle server -> client streaming
	go func() {
		for {
			select {
			case streamMsg := <-call.StreamChan:
				if streamMsg == nil {
					errChan <- nil
					return
				}
				var resp StreamMethodResponse
				if err := streamMsg.Message.UnmarshalTo(&resp); err != nil {
					errChan <- err
					return
				}
				if err := stream.Send(&resp); err != nil {
					errChan <- err
					return
				}
			case err := <-call.ErrorChan:
				errChan <- err
				return
			case <-call.Context.Done():
				errChan <- call.Context.Err()
				return
			}
		}
	}()

	// Wait for completion
	return <-errChan
}

// extractRoutingKey extracts the routing key from context or request
func (r *MyServiceRouter) extractRoutingKey(ctx context.Context, req interface{}) string {
	// TODO: Implement routing key extraction based on routing strategy
	// For now, extract from gRPC metadata
	if md, ok := metadata.FromIncomingContext(ctx); ok {
		if values := md.Get("instanceid"); len(values) > 0 {
			return values[0]
		}
	}
	return ""
}

// routeRPC routes an RPC call to an appropriate service instance
func (r *MyServiceRouter) routeRPC(ctx context.Context, serviceName, method string, methodType pb.RpcMethodType, request *anypb.Any, routingKey string) (*router.PendingCall, error) {
	// Use the shared router server to handle the routing
	return r.routerServer.RouteRPC(ctx, serviceName, method, methodType, request, nil, routingKey)
}

// sendStreamMessage sends a stream message for an active RPC call
func (r *MyServiceRouter) sendStreamMessage(requestID string, message *anypb.Any, control pb.StreamControl) error {
	return r.routerServer.SendStreamMessage(requestID, message, control)
}

// sendStreamControl sends a stream control signal
func (r *MyServiceRouter) sendStreamControl(requestID string, control pb.StreamControl) error {
	return r.sendStreamMessage(requestID, nil, control)
}
