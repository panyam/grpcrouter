// Code generated by protoc-gen-grpcrouter. DO NOT EDIT.
// source: myservice/v1/service.proto

package myservicev1

import (
	"context"
	"io"
	"log"
	"sync"
	"time"

	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/metadata"
	"google.golang.org/grpc/status"
	"google.golang.org/protobuf/types/known/anypb"

	"github.com/panyam/grpcrouter/router"
	pb "github.com/panyam/grpcrouter/proto/gen/go/grpcrouter/v1"
)

// MyServiceRouter implements MyService interface with routing capabilities
type MyServiceRouter struct {
	UnimplementedMyServiceServer
	pb.UnimplementedRouterServer

	// Core routing components
	correlator *router.RequestCorrelator
	registry   *router.ServiceRegistry
	config     *router.RouterConfig

	// Service instance management
	instances    map[string]*router.ServiceInstance
	instancesMux sync.RWMutex
}

// NewMyServiceRouter creates a new MyService router
func NewMyServiceRouter(config *router.RouterConfig) *MyServiceRouter {
	if config == nil {
		config = &router.RouterConfig{
			DefaultTimeout:      30 * time.Second,
			MaxConcurrentRPCs:   1000,
			HealthCheckInterval: 30 * time.Second,
		}
	}
	return &MyServiceRouter{
		correlator: router.NewRequestCorrelator(),
		registry:   router.NewServiceRegistry(),
		config:     config,
		instances:  make(map[string]*router.ServiceInstance),
	}
}

// Register handles service instance registration
func (r *MyServiceRouter) Register(stream pb.Router_RegisterServer) error {
	log.Println("Did we come here????")
	// Wait for initial registration message
	req, err := stream.Recv()
	if err != nil {
		return status.Errorf(codes.Internal, "failed to receive registration: %v", err)
	}

	// Extract instance info
	instanceMsg := req.GetInstanceInfo()
	if instanceMsg == nil {
	log.Println("2. Did we come here????")
		return status.Errorf(codes.InvalidArgument, "expected instance info in first message")
	}

	// Validate service name
	if instanceMsg.ServiceName != "MyService" {
	log.Println("3. Did we come here????")
		return status.Errorf(codes.InvalidArgument, "service name mismatch: expected MyService, got %s", instanceMsg.ServiceName)
	}

	log.Println("4. and Did we come here????")
	// Create service instance
	instance := &router.ServiceInstance{
		InstanceID:    instanceMsg.InstanceId,
		ServiceName:   instanceMsg.ServiceName,
		Endpoint:      instanceMsg.Endpoint,
		Metadata:      instanceMsg.Metadata,
		HealthStatus:  instanceMsg.HealthStatus,
		RegisteredAt:  time.Now(),
		LastHeartbeat: time.Now(),
		Stream:        stream,
		RequestQueue:  make(chan *pb.RpcCall, 100),
		ResponseQueue: make(chan *pb.RpcResponse, 100),
		Connected:     true,
	}

	// Register instance
	r.instancesMux.Lock()
	r.instances[instanceMsg.InstanceId] = instance
	r.instancesMux.Unlock()

	if err := r.registry.RegisterInstance(instance); err != nil {
		r.instancesMux.Lock()
		delete(r.instances, instanceMsg.InstanceId)
		r.instancesMux.Unlock()
		return status.Errorf(codes.AlreadyExists, "failed to register instance: %v", err)
	}

	// Send registration acknowledgment
	ack := &pb.RegisterResponse{
		Response: &pb.RegisterResponse_Ack{
			Ack: &pb.RegistrationAck{
				InstanceId: instanceMsg.InstanceId,
				Success:    true,
				Message:    "Registration successful",
			},
		},
	}

	if err := stream.Send(ack); err != nil {
		r.unregisterInstance(instanceMsg.InstanceId)
		return status.Errorf(codes.Internal, "failed to send acknowledgment: %v", err)
	}

	log.Printf("Service instance registered: %s (MyService)", instanceMsg.InstanceId)

	// Start instance handling goroutines
	go r.handleInstanceRequests(instance)
	go r.handleInstanceResponses(instance)

	// Handle incoming messages from the instance
	return r.handleInstanceMessages(instance)
}

// Method1 implements the Method1 method with routing
func (r *MyServiceRouter) Method1(ctx context.Context, req *Method1Request) (*Method1Response, error) {
	// Extract routing key from metadata or request
	routingKey := r.extractRoutingKey(ctx, req)

	// Convert request to Any
	reqAny, err := anypb.New(req)
	if err != nil {
		return nil, status.Errorf(codes.Internal, "failed to marshal request: %v", err)
	}

	// Route the call
	call, err := r.routeRPC(ctx, "MyService", "/MyService/Method1", pb.RpcMethodType_UNARY, reqAny, routingKey)
	if err != nil {
		return nil, err
	}

	// Wait for response
	select {
	case respAny := <-call.ResponseChan:
		var resp Method1Response
		if err := respAny.UnmarshalTo(&resp); err != nil {
			return nil, status.Errorf(codes.Internal, "failed to unmarshal response: %v", err)
		}
		return &resp, nil
	case err := <-call.ErrorChan:
		return nil, err
	case <-call.Context.Done():
		return nil, call.Context.Err()
	}
}

// Method2 implements the Method2 method with routing
func (r *MyServiceRouter) Method2(req *Method2Request, stream MyService_Method2Server) error {
	// Extract routing key
	routingKey := r.extractRoutingKey(stream.Context(), req)

	// Convert request to Any
	reqAny, err := anypb.New(req)
	if err != nil {
		return status.Errorf(codes.Internal, "failed to marshal request: %v", err)
	}

	// Route the call
	call, err := r.routeRPC(stream.Context(), "MyService", "/MyService/Method2", pb.RpcMethodType_SERVER_STREAMING, reqAny, routingKey)
	if err != nil {
		return err
	}

	// Stream responses back to client
	for {
		select {
		case streamMsg := <-call.StreamChan:
			if streamMsg == nil {
				return nil // Stream closed
			}
			var resp Method2Response
			if err := streamMsg.Message.UnmarshalTo(&resp); err != nil {
				return status.Errorf(codes.Internal, "failed to unmarshal response: %v", err)
			}
			if err := stream.Send(&resp); err != nil {
				return err
			}
		case err := <-call.ErrorChan:
			return err
		case <-call.Context.Done():
			return call.Context.Err()
		}
	}
}

// Method3 implements the Method3 method with routing
func (r *MyServiceRouter) Method3(stream MyService_Method3Server) error {
	// Read first message to establish routing
	firstMsg, err := stream.Recv()
	if err != nil {
		return err
	}

	// Extract routing key
	routingKey := r.extractRoutingKey(stream.Context(), firstMsg)

	// Convert first message to Any
	firstAny, err := anypb.New(firstMsg)
	if err != nil {
		return status.Errorf(codes.Internal, "failed to marshal request: %v", err)
	}

	// Route the call
	call, err := r.routeRPC(stream.Context(), "MyService", "/MyService/Method3", pb.RpcMethodType_CLIENT_STREAMING, firstAny, routingKey)
	if err != nil {
		return err
	}

	// Stream remaining messages
	go func() {
		defer r.sendStreamControl(call.RequestID, pb.StreamControl_HALF_CLOSE)
		for {
			msg, err := stream.Recv()
			if err == io.EOF {
				return
			}
			if err != nil {
				log.Printf("Stream receive error: %v", err)
				return
			}

			msgAny, err := anypb.New(msg)
			if err != nil {
				log.Printf("Failed to marshal stream message: %v", err)
				return
			}

			if err := r.sendStreamMessage(call.RequestID, msgAny, pb.StreamControl_MESSAGE); err != nil {
				log.Printf("Failed to send stream message: %v", err)
				return
			}
		}
	}()

	// Wait for final response
	select {
	case respAny := <-call.ResponseChan:
		var resp Method3Response
		if err := respAny.UnmarshalTo(&resp); err != nil {
			return status.Errorf(codes.Internal, "failed to unmarshal response: %v", err)
		}
		return stream.SendAndClose(&resp)
	case err := <-call.ErrorChan:
		return err
	case <-call.Context.Done():
		return call.Context.Err()
	}
}

// StreamMethod implements the StreamMethod method with routing
func (r *MyServiceRouter) StreamMethod(stream MyService_StreamMethodServer) error {
	// Read first message to establish routing
	firstMsg, err := stream.Recv()
	if err != nil {
		return err
	}

	// Extract routing key
	routingKey := r.extractRoutingKey(stream.Context(), firstMsg)

	// Convert first message to Any
	firstAny, err := anypb.New(firstMsg)
	if err != nil {
		return status.Errorf(codes.Internal, "failed to marshal request: %v", err)
	}

	// Route the call
	call, err := r.routeRPC(stream.Context(), "MyService", "/MyService/StreamMethod", pb.RpcMethodType_BIDIRECTIONAL_STREAMING, firstAny, routingKey)
	if err != nil {
		return err
	}

	// Handle bidirectional streaming
	errChan := make(chan error, 2)

	// Goroutine to handle client -> server streaming
	go func() {
		defer r.sendStreamControl(call.RequestID, pb.StreamControl_HALF_CLOSE)
		for {
			msg, err := stream.Recv()
			if err == io.EOF {
				errChan <- nil
				return
			}
			if err != nil {
				errChan <- err
				return
			}

			msgAny, err := anypb.New(msg)
			if err != nil {
				errChan <- err
				return
			}

			if err := r.sendStreamMessage(call.RequestID, msgAny, pb.StreamControl_MESSAGE); err != nil {
				errChan <- err
				return
			}
		}
	}()

	// Goroutine to handle server -> client streaming
	go func() {
		for {
			select {
			case streamMsg := <-call.StreamChan:
				if streamMsg == nil {
					errChan <- nil
					return
				}
				var resp StreamMethodResponse
				if err := streamMsg.Message.UnmarshalTo(&resp); err != nil {
					errChan <- err
					return
				}
				if err := stream.Send(&resp); err != nil {
					errChan <- err
					return
				}
			case err := <-call.ErrorChan:
				errChan <- err
				return
			case <-call.Context.Done():
				errChan <- call.Context.Err()
				return
			}
		}
	}()

	// Wait for completion
	return <-errChan
}

// extractRoutingKey extracts the routing key from context or request
func (r *MyServiceRouter) extractRoutingKey(ctx context.Context, req interface{}) string {
	// TODO: Implement routing key extraction based on routing strategy
	// For now, extract from gRPC metadata
	if md, ok := metadata.FromIncomingContext(ctx); ok {
		if values := md.Get("instanceid"); len(values) > 0 {
			return values[0]
		}
	}
	return ""
}

// routeRPC routes an RPC call to an appropriate service instance
func (r *MyServiceRouter) routeRPC(ctx context.Context, serviceName, method string, methodType pb.RpcMethodType, request *anypb.Any, routingKey string) (*router.PendingCall, error) {
	// Find appropriate instance
	instance, err := r.registry.SelectInstance(serviceName, routingKey)
	if err != nil {
		return nil, status.Errorf(codes.Unavailable, "no available instance for service %s: %v", serviceName, err)
	}

	// Create pending call
	call := r.correlator.CreatePendingCall(ctx, method, methodType, r.config.DefaultTimeout)

	// Create RPC call message
	rpcCall := &pb.RpcCall{
		RequestId:  call.RequestID,
		Method:     method,
		MethodType: methodType,
		Payload:    &pb.RpcCall_Request{Request: request},
		Metadata:   make(map[string]string),
	}

	// Send RPC call to instance
	select {
	case instance.RequestQueue <- rpcCall:
		return call, nil
	case <-ctx.Done():
		r.correlator.CompletePendingCall(call.RequestID, ctx.Err())
		return nil, ctx.Err()
	default:
		r.correlator.CompletePendingCall(call.RequestID, nil)
		return nil, status.Errorf(codes.ResourceExhausted, "request queue full for instance %s", instance.InstanceID)
	}
}

// sendStreamMessage sends a stream message for an active RPC call
func (r *MyServiceRouter) sendStreamMessage(requestID string, message *anypb.Any, control pb.StreamControl) error {
	// TODO: Implement stream message sending
	return nil
}

// sendStreamControl sends a stream control signal
func (r *MyServiceRouter) sendStreamControl(requestID string, control pb.StreamControl) error {
	return r.sendStreamMessage(requestID, nil, control)
}

// unregisterInstance removes an instance from the router
func (r *MyServiceRouter) unregisterInstance(instanceID string) {
	r.instancesMux.Lock()
	delete(r.instances, instanceID)
	r.instancesMux.Unlock()
	r.registry.UnregisterInstance(instanceID)
}

// handleInstanceMessages processes incoming messages from a service instance
func (r *MyServiceRouter) handleInstanceMessages(instance *router.ServiceInstance) error {
	defer func() {
		r.unregisterInstance(instance.InstanceID)
		log.Printf("Service instance disconnected: %s", instance.InstanceID)
	}()

	for {
		req, err := instance.Stream.Recv()
		if err != nil {
			return err
		}

		switch msg := req.Request.(type) {
		case *pb.RegisterRequest_Heartbeat:
			r.handleHeartbeat(instance, msg.Heartbeat)
		case *pb.RegisterRequest_RpcResponse:
			r.handleRpcResponse(instance, msg.RpcResponse)
		}
	}
}

// handleInstanceRequests sends RPC requests to the service instance
func (r *MyServiceRouter) handleInstanceRequests(instance *router.ServiceInstance) {
	for {
		select {
		case <-instance.Stream.Context().Done():
			return
		case rpcCall := <-instance.RequestQueue:
			response := &pb.RegisterResponse{
				Response: &pb.RegisterResponse_RpcCall{
					RpcCall: rpcCall,
				},
			}
			if err := instance.Stream.Send(response); err != nil {
				log.Printf("Failed to send RPC call to instance %s: %v", instance.InstanceID, err)
				return
			}
		}
	}
}

// handleInstanceResponses processes RPC responses from the service instance
func (r *MyServiceRouter) handleInstanceResponses(instance *router.ServiceInstance) {
	for {
		select {
		case <-instance.Stream.Context().Done():
			return
		case rpcResponse := <-instance.ResponseQueue:
			if err := r.correlator.HandleResponse(rpcResponse); err != nil {
				log.Printf("Failed to handle RPC response: %v", err)
			}
		}
	}
}

// handleHeartbeat processes heartbeat messages from service instances
func (r *MyServiceRouter) handleHeartbeat(instance *router.ServiceInstance, heartbeat *pb.Heartbeat) {
	instance.LastHeartbeat = time.Now()
	instance.HealthStatus = heartbeat.HealthStatus
	r.registry.UpdateInstanceHealth(instance.InstanceID, heartbeat.HealthStatus)
}

// handleRpcResponse processes RPC responses from service instances
func (r *MyServiceRouter) handleRpcResponse(instance *router.ServiceInstance, response *pb.RpcResponse) {
	select {
	case instance.ResponseQueue <- response:
	default:
		log.Printf("Response queue full for instance %s", instance.InstanceID)
	}
}
