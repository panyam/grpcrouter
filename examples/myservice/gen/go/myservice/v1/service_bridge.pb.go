// Code generated by protoc-gen-grpcrouter. DO NOT EDIT.
// source: myservice/v1/service.proto

package v1

import (
	"context"
	"fmt"
	"log"
	"sync"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials/insecure"
	"google.golang.org/protobuf/types/known/timestamppb"

	pb "github.com/panyam/grpcrouter/proto/gen/go/grpcrouter/v1"
)

// MyServiceBridgeOptions configures the service bridge
type MyServiceBridgeOptions struct {
	// Instance identification
	InstanceID string
	Endpoint   string

	// Connection settings
	RouterAddr        string
	ReconnectInterval time.Duration
	HeartbeatInterval time.Duration

	// Service metadata
	Metadata map[string]string

	// Optional custom context
	Context context.Context
}

// DefaultMyServiceBridgeOptions returns sensible defaults
func DefaultMyServiceBridgeOptions() *MyServiceBridgeOptions {
	return &MyServiceBridgeOptions{
		InstanceID:        fmt.Sprintf("MyService-bridge-%d", time.Now().Unix()%10000),
		RouterAddr:        "localhost:9080",
		ReconnectInterval: 5 * time.Second,
		HeartbeatInterval: 30 * time.Second,
		Metadata:          make(map[string]string),
		Context:           context.Background(),
	}
}

// MyServiceBridge wraps a MyServiceServer and connects it to a MyServiceRouter
type MyServiceBridge struct {
	// Service implementation
	service MyServiceServer

	// Configuration
	options *MyServiceBridgeOptions

	// Connection state
	conn   *grpc.ClientConn
	client MyServiceRouterClient
	stream MyServiceRouter_RegisterClient

	// Lifecycle management
	ctx     context.Context
	cancel  context.CancelFunc
	started bool
	stopped bool
	done    chan struct{}
	mu      sync.RWMutex
}

// NewMyServiceBridge creates a new service bridge
func NewMyServiceBridge(service MyServiceServer, options *MyServiceBridgeOptions) *MyServiceBridge {
	if options == nil {
		options = DefaultMyServiceBridgeOptions()
	}

	// Auto-generate endpoint if not provided
	if options.Endpoint == "" {
		options.Endpoint = fmt.Sprintf("bridge-%s", options.InstanceID)
	}

	// Set up service metadata
	if options.Metadata == nil {
		options.Metadata = make(map[string]string)
	}
	options.Metadata["bridge_type"] = "auto-generated"
	options.Metadata["service_type"] = "MyService"
	options.Metadata["routing_key"] = options.InstanceID

	ctx := options.Context
	if ctx == nil {
		ctx = context.Background()
	}

	return &MyServiceBridge{
		service: service,
		options: options,
		done:    make(chan struct{}),
	}
}

// Start connects the bridge to the router and begins processing
func (b *MyServiceBridge) Start() error {
	b.mu.Lock()
	defer b.mu.Unlock()

	if b.started {
		return fmt.Errorf("bridge already started")
	}

	if b.stopped {
		return fmt.Errorf("bridge has been stopped and cannot be restarted")
	}

	// Set up context
	b.ctx, b.cancel = context.WithCancel(b.options.Context)

	// Connect and start
	if err := b.connect(); err != nil {
		return fmt.Errorf("failed to connect: %v", err)
	}

	b.started = true
	log.Printf("[%s] MyServiceBridge started", b.options.InstanceID)
	return nil
}

// Stop gracefully shuts down the bridge
func (b *MyServiceBridge) Stop() {
	b.mu.Lock()
	if !b.started || b.stopped {
		b.mu.Unlock()
		return
	}
	b.stopped = true
	b.mu.Unlock()

	// Cancel context to stop all goroutines
	if b.cancel != nil {
		b.cancel()
	}

	// Close connection
	if b.conn != nil {
		b.conn.Close()
	}

	// Signal completion
	close(b.done)
	log.Printf("[%s] MyServiceBridge stopped", b.options.InstanceID)
}

// Wait blocks until the bridge is stopped
func (b *MyServiceBridge) Wait() {
	<-b.done
}

// connect establishes connection to router and handles registration
func (b *MyServiceBridge) connect() error {
	// Connect to router
	conn, err := grpc.Dial(b.options.RouterAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))
	if err != nil {
		return fmt.Errorf("failed to dial router at %s: %v", b.options.RouterAddr, err)
	}

	b.conn = conn
	b.client = NewMyServiceRouterClient(conn)

	// Create registration stream
	stream, err := b.client.Register(b.ctx)
	if err != nil {
		return fmt.Errorf("failed to create registration stream: %v", err)
	}
	b.stream = stream

	// Send initial registration
	if err := b.sendRegistration(); err != nil {
		return fmt.Errorf("failed to send registration: %v", err)
	}

	// Start background goroutines
	go b.handleHeartbeats()
	go b.handleRegistrationResponses()

	return nil
}

// sendRegistration sends the initial registration message
func (b *MyServiceBridge) sendRegistration() error {
	req := &MyServiceRegisterRequest{
		Request: &MyServiceRegisterRequest_InstanceInfo{
			InstanceInfo: &pb.InstanceInfo{
				InstanceId:   b.options.InstanceID,
				ServiceName:  "MyService",
				Endpoint:     b.options.Endpoint,
				Metadata:     b.options.Metadata,
				HealthStatus: pb.HealthStatus_HEALTHY,
				RegisteredAt: timestamppb.Now(),
			},
		},
	}

	return b.stream.Send(req)
}

// handleHeartbeats sends periodic heartbeat messages
func (b *MyServiceBridge) handleHeartbeats() {
	ticker := time.NewTicker(b.options.HeartbeatInterval)
	defer ticker.Stop()

	for {
		select {
		case <-ticker.C:
			heartbeat := &MyServiceRegisterRequest{
				Request: &MyServiceRegisterRequest_Heartbeat{
					Heartbeat: &pb.Heartbeat{
						InstanceId:   b.options.InstanceID,
						Timestamp:    timestamppb.Now(),
						HealthStatus: pb.HealthStatus_HEALTHY,
					},
				},
			}

			if err := b.stream.Send(heartbeat); err != nil {
				log.Printf("[%s] Failed to send heartbeat: %v", b.options.InstanceID, err)
				return
			}

		case <-b.ctx.Done():
			return
		}
	}
}

// handleRegistrationResponses processes messages from the router
func (b *MyServiceBridge) handleRegistrationResponses() {
	for {
		select {
		case <-b.ctx.Done():
			return
		default:
		}

		resp, err := b.stream.Recv()
		if err != nil {
			log.Printf("[%s] Registration stream error: %v", b.options.InstanceID, err)
			return
		}

		switch msg := resp.Response.(type) {
		case *MyServiceRegisterResponse_Ack:
			if msg.Ack.Success {
				log.Printf("[%s] Registration acknowledged: %s", b.options.InstanceID, msg.Ack.Message)
			} else {
				log.Printf("[%s] Registration failed: %s", b.options.InstanceID, msg.Ack.Message)
			}

		case *MyServiceRegisterResponse_RpcCall:
			// Handle incoming RPC call
			go b.handleRPCCall(msg.RpcCall)

		case *MyServiceRegisterResponse_Error:
			log.Printf("[%s] Router error: %s", b.options.InstanceID, msg.Error.Message)

		default:
			log.Printf("[%s] Unknown response type", b.options.InstanceID)
		}
	}
}

// handleRPCCall processes incoming RPC calls and dispatches to service methods
func (b *MyServiceBridge) handleRPCCall(rpcCall *MyServiceRpcCall) {
	log.Printf("[%s] Handling RPC call: %s (ID: %s)", b.options.InstanceID, rpcCall.Method, rpcCall.RequestId)

	var response *MyServiceRpcResponse

	// Dispatch based on typed request oneof
	switch req := rpcCall.Request.(type) {
	case *MyServiceRpcCall_Method1:
		response = b.handleMethod1(rpcCall.RequestId, req.Method1)

	case *MyServiceRpcCall_Method2:
		response = b.handleMethod2(rpcCall.RequestId, req.Method2)

	case *MyServiceRpcCall_Method3:
		response = b.handleMethod3(rpcCall.RequestId, req.Method3)

	case *MyServiceRpcCall_StreamMethod:
		response = b.handleStreamMethod(rpcCall.RequestId, req.StreamMethod)

	default:
		log.Printf("[%s] Unknown method in RPC call", b.options.InstanceID)
		response = &MyServiceRpcResponse{
			RequestId: rpcCall.RequestId,
			Status: &pb.RpcStatus{
				Code:    12, // UNIMPLEMENTED
				Message: "Method not implemented",
			},
			Metadata: make(map[string]string),
		}
	}

	// Send response
	b.sendResponse(response)
}

// handleMethod1 handles Method1 RPC calls
func (b *MyServiceBridge) handleMethod1(requestID string, req *Method1Request) *MyServiceRpcResponse {
	log.Printf("[%s] Processing Method1 request", b.options.InstanceID)

	// Call the service method
	ctx := context.Background()
	resp, err := b.service.Method1(ctx, req)

	if err != nil {
		log.Printf("[%s] Method1 call failed: %v", b.options.InstanceID, err)
		return &MyServiceRpcResponse{
			RequestId: requestID,
			Status: &pb.RpcStatus{
				Code:    13, // INTERNAL
				Message: fmt.Sprintf("Service method failed: %v", err),
			},
			Metadata: make(map[string]string),
		}
	}

	log.Printf("[%s] Method1 completed successfully", b.options.InstanceID)
	return &MyServiceRpcResponse{
		RequestId: requestID,
		Status: &pb.RpcStatus{
			Code:    0, // OK
			Message: "Success",
		},
		Metadata: make(map[string]string),
		Response: &MyServiceRpcResponse_Method1{Method1: resp},
	}
}

// handleMethod2 handles Method2 RPC calls (streaming)
func (b *MyServiceBridge) handleMethod2(requestID string, req *Method2Request) *MyServiceRpcResponse {
	log.Printf("[%s] Processing Method2 streaming request", b.options.InstanceID)

	// For server streaming, we process single request and return multiple responses
	// This requires establishing a streaming response mechanism

	// Note: Actual streaming implementation requires gRPC stream coordination
	// For now, we simulate a successful streaming initiation
	_ = req // Avoid unused variable warning for now

	log.Printf("[%s] Method2 streaming initiated successfully", b.options.InstanceID)
	return &MyServiceRpcResponse{
		RequestId: requestID,
		Status: &pb.RpcStatus{
			Code:    0, // OK
			Message: "Streaming call initiated successfully",
		},
		Metadata: make(map[string]string),
		// Note: Streaming responses will be sent separately through the stream
	}
}

// handleMethod3 handles Method3 RPC calls (streaming)
func (b *MyServiceBridge) handleMethod3(requestID string, req *Method3Request) *MyServiceRpcResponse {
	log.Printf("[%s] Processing Method3 streaming request", b.options.InstanceID)

	// For client streaming, we expect multiple requests and single response
	// This requires establishing a collection mechanism

	// Note: Actual streaming implementation requires gRPC stream coordination
	// For now, we simulate a successful streaming initiation
	_ = req // Avoid unused variable warning for now

	log.Printf("[%s] Method3 streaming initiated successfully", b.options.InstanceID)
	return &MyServiceRpcResponse{
		RequestId: requestID,
		Status: &pb.RpcStatus{
			Code:    0, // OK
			Message: "Streaming call initiated successfully",
		},
		Metadata: make(map[string]string),
		// Note: Streaming responses will be sent separately through the stream
	}
}

// handleStreamMethod handles StreamMethod RPC calls (streaming)
func (b *MyServiceBridge) handleStreamMethod(requestID string, req *StreamMethodRequest) *MyServiceRpcResponse {
	log.Printf("[%s] Processing StreamMethod streaming request", b.options.InstanceID)

	// For bidirectional streaming, we need to establish a streaming context
	// This is a complex operation that requires coordination with the router
	// For now, return appropriate status indicating streaming capability

	// Note: Actual streaming implementation requires gRPC stream coordination
	// For now, we simulate a successful streaming initiation
	_ = req // Avoid unused variable warning for now

	log.Printf("[%s] StreamMethod streaming initiated successfully", b.options.InstanceID)
	return &MyServiceRpcResponse{
		RequestId: requestID,
		Status: &pb.RpcStatus{
			Code:    0, // OK
			Message: "Streaming call initiated successfully",
		},
		Metadata: make(map[string]string),
		// Note: Streaming responses will be sent separately through the stream
	}
}

// sendResponse sends a typed response back to the router
func (b *MyServiceBridge) sendResponse(response *MyServiceRpcResponse) {
	req := &MyServiceRegisterRequest{
		Request: &MyServiceRegisterRequest_RpcResponse{
			RpcResponse: response,
		},
	}

	if err := b.stream.Send(req); err != nil {
		log.Printf("[%s] Failed to send response: %v", b.options.InstanceID, err)
	}
}
