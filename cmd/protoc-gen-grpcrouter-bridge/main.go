package main

import (
	"fmt"
	"log"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			// Only process original service proto files (not generated router protos)
			if isGeneratedRouterProto(f) {
				continue
			}

			// Check if file has services that could benefit from bridge generation
			for _, service := range f.Services {
				if err := generateServiceBridge(gen, f, service); err != nil {
					return fmt.Errorf("failed to generate bridge for service %s: %v", service.GoName, err)
				}
			}
		}

		return nil
	})
}

// isGeneratedRouterProto checks if this is a generated router proto file
func isGeneratedRouterProto(f *protogen.File) bool {
	return strings.Contains(string(f.Desc.Path()), "_router")
}

// generateServiceBridge generates the service bridge for a given service
func generateServiceBridge(gen *protogen.Plugin, f *protogen.File, service *protogen.Service) error {
	serviceName := service.GoName
	bridgeName := serviceName + "Bridge"
	
	// Create output filename
	baseFileName := strings.TrimSuffix(string(f.Desc.Path()), ".proto")
	outputPath := baseFileName + "_bridge.pb.go"

	// Generate the bridge file
	genFile := gen.NewGeneratedFile(outputPath, f.GoImportPath)
	
	if err := generateBridgeContent(genFile, f, service, serviceName, bridgeName); err != nil {
		return fmt.Errorf("failed to generate bridge content: %v", err)
	}

	log.Printf("Generated service bridge: %s", outputPath)
	return nil
}

// generateBridgeContent generates the service bridge implementation
func generateBridgeContent(g *protogen.GeneratedFile, f *protogen.File, service *protogen.Service, serviceName, bridgeName string) error {
	// Package and imports
	g.P("// Code generated by protoc-gen-grpcrouter-bridge. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P()
	g.P("package ", f.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`"context"`)
	g.P(`"fmt"`)
	g.P(`"log"`)
	g.P(`"sync"`)
	g.P(`"time"`)
	g.P()
	g.P(`"google.golang.org/grpc"`)
	g.P(`"google.golang.org/grpc/credentials/insecure"`)
	g.P(`"google.golang.org/protobuf/types/known/timestamppb"`)
	g.P()
	g.P(`pb "github.com/panyam/grpcrouter/proto/gen/go/grpcrouter/v1"`)
	g.P(")")
	g.P()

	// Generate bridge options struct
	if err := generateBridgeOptions(g, serviceName); err != nil {
		return err
	}

	// Generate main bridge struct
	if err := generateBridgeStruct(g, serviceName, bridgeName); err != nil {
		return err
	}

	// Generate constructor
	if err := generateBridgeConstructor(g, serviceName, bridgeName); err != nil {
		return err
	}

	// Generate lifecycle methods
	if err := generateBridgeLifecycle(g, serviceName, bridgeName); err != nil {
		return err
	}

	// Generate connection management
	if err := generateConnectionManagement(g, serviceName, bridgeName); err != nil {
		return err
	}

	// Generate RPC dispatch logic
	if err := generateRPCDispatch(g, service, serviceName, bridgeName); err != nil {
		return err
	}

	return nil
}

// generateBridgeOptions generates the bridge configuration options
func generateBridgeOptions(g *protogen.GeneratedFile, serviceName string) error {
	g.P("// ", serviceName, "BridgeOptions configures the service bridge")
	g.P("type ", serviceName, "BridgeOptions struct {")
	g.P("// Instance identification")
	g.P("InstanceID string")
	g.P("Endpoint   string")
	g.P()
	g.P("// Connection settings")
	g.P("RouterAddr         string")
	g.P("ReconnectInterval  time.Duration")
	g.P("HeartbeatInterval  time.Duration")
	g.P()
	g.P("// Service metadata")
	g.P("Metadata map[string]string")
	g.P()
	g.P("// Optional custom context")
	g.P("Context context.Context")
	g.P("}")
	g.P()

	// Generate default options function
	g.P("// Default", serviceName, "BridgeOptions returns sensible defaults")
	g.P("func Default", serviceName, "BridgeOptions() *", serviceName, "BridgeOptions {")
	g.P("return &", serviceName, "BridgeOptions{")
	g.P(`InstanceID:        fmt.Sprintf("`, serviceName, `-bridge-%d", time.Now().Unix()%10000),`)
	g.P(`RouterAddr:        "localhost:9080",`)
	g.P("ReconnectInterval: 5 * time.Second,")
	g.P("HeartbeatInterval: 30 * time.Second,")
	g.P("Metadata:          make(map[string]string),")
	g.P("Context:           context.Background(),")
	g.P("}")
	g.P("}")
	g.P()

	return nil
}

// generateBridgeStruct generates the main bridge struct
func generateBridgeStruct(g *protogen.GeneratedFile, serviceName, bridgeName string) error {
	g.P("// ", bridgeName, " wraps a ", serviceName, "Server and connects it to a ", serviceName, "Router")
	g.P("type ", bridgeName, " struct {")
	g.P("// Service implementation")
	g.P("service ", serviceName, "Server")
	g.P()
	g.P("// Configuration")
	g.P("options *", serviceName, "BridgeOptions")
	g.P()
	g.P("// Connection state")
	g.P("conn     *grpc.ClientConn")
	g.P("client   ", serviceName, "RouterClient")
	g.P("stream   ", serviceName, "Router_RegisterClient")
	g.P()
	g.P("// Lifecycle management")
	g.P("ctx      context.Context")
	g.P("cancel   context.CancelFunc")
	g.P("started  bool")
	g.P("stopped  bool")
	g.P("done     chan struct{}")
	g.P("mu       sync.RWMutex")
	g.P("}")
	g.P()

	return nil
}

// generateBridgeConstructor generates the bridge constructor
func generateBridgeConstructor(g *protogen.GeneratedFile, serviceName, bridgeName string) error {
	g.P("// New", bridgeName, " creates a new service bridge")
	g.P("func New", bridgeName, "(service ", serviceName, "Server, options *", serviceName, "BridgeOptions) *", bridgeName, " {")
	g.P("if options == nil {")
	g.P("options = Default", serviceName, "BridgeOptions()")
	g.P("}")
	g.P()
	g.P("// Auto-generate endpoint if not provided")
	g.P("if options.Endpoint == \"\" {")
	g.P(`options.Endpoint = fmt.Sprintf("bridge-%s", options.InstanceID)`)
	g.P("}")
	g.P()
	g.P("// Set up service metadata")
	g.P("if options.Metadata == nil {")
	g.P("options.Metadata = make(map[string]string)")
	g.P("}")
	g.P(`options.Metadata["bridge_type"] = "auto-generated"`)
	g.P(`options.Metadata["service_type"] = "`, serviceName, `"`)
	g.P(`options.Metadata["routing_key"] = options.InstanceID`)
	g.P()
	g.P("ctx := options.Context")
	g.P("if ctx == nil {")
	g.P("ctx = context.Background()")
	g.P("}")
	g.P()
	g.P("return &", bridgeName, "{")
	g.P("service: service,")
	g.P("options: options,")
	g.P("done:    make(chan struct{}),")
	g.P("}")
	g.P("}")
	g.P()

	return nil
}

// generateBridgeLifecycle generates Start, Stop, and Wait methods
func generateBridgeLifecycle(g *protogen.GeneratedFile, serviceName, bridgeName string) error {
	// Start method
	g.P("// Start connects the bridge to the router and begins processing")
	g.P("func (b *", bridgeName, ") Start() error {")
	g.P("b.mu.Lock()")
	g.P("defer b.mu.Unlock()")
	g.P()
	g.P("if b.started {")
	g.P(`return fmt.Errorf("bridge already started")`)
	g.P("}")
	g.P()
	g.P("if b.stopped {")
	g.P(`return fmt.Errorf("bridge has been stopped and cannot be restarted")`)
	g.P("}")
	g.P()
	g.P("// Set up context")
	g.P("b.ctx, b.cancel = context.WithCancel(b.options.Context)")
	g.P()
	g.P("// Connect and start")
	g.P("if err := b.connect(); err != nil {")
	g.P(`return fmt.Errorf("failed to connect: %v", err)`)
	g.P("}")
	g.P()
	g.P("b.started = true")
	g.P(`log.Printf("[%s] `, serviceName, `Bridge started", b.options.InstanceID)`)
	g.P("return nil")
	g.P("}")
	g.P()

	// Stop method
	g.P("// Stop gracefully shuts down the bridge")
	g.P("func (b *", bridgeName, ") Stop() {")
	g.P("b.mu.Lock()")
	g.P("if !b.started || b.stopped {")
	g.P("b.mu.Unlock()")
	g.P("return")
	g.P("}")
	g.P("b.stopped = true")
	g.P("b.mu.Unlock()")
	g.P()
	g.P("// Cancel context to stop all goroutines")
	g.P("if b.cancel != nil {")
	g.P("b.cancel()")
	g.P("}")
	g.P()
	g.P("// Close connection")
	g.P("if b.conn != nil {")
	g.P("b.conn.Close()")
	g.P("}")
	g.P()
	g.P("// Signal completion")
	g.P("close(b.done)")
	g.P(`log.Printf("[%s] `, serviceName, `Bridge stopped", b.options.InstanceID)`)
	g.P("}")
	g.P()

	// Wait method
	g.P("// Wait blocks until the bridge is stopped")
	g.P("func (b *", bridgeName, ") Wait() {")
	g.P("<-b.done")
	g.P("}")
	g.P()

	return nil
}

// generateConnectionManagement generates connection and registration logic
func generateConnectionManagement(g *protogen.GeneratedFile, serviceName, bridgeName string) error {
	// Connect method
	g.P("// connect establishes connection to router and handles registration")
	g.P("func (b *", bridgeName, ") connect() error {")
	g.P("// Connect to router")
	g.P("conn, err := grpc.Dial(b.options.RouterAddr, grpc.WithTransportCredentials(insecure.NewCredentials()))")
	g.P("if err != nil {")
	g.P(`return fmt.Errorf("failed to dial router at %s: %v", b.options.RouterAddr, err)`)
	g.P("}")
	g.P()
	g.P("b.conn = conn")
	g.P("b.client = New", serviceName, "RouterClient(conn)")
	g.P()
	g.P("// Create registration stream")
	g.P("stream, err := b.client.Register(b.ctx)")
	g.P("if err != nil {")
	g.P(`return fmt.Errorf("failed to create registration stream: %v", err)`)
	g.P("}")
	g.P("b.stream = stream")
	g.P()
	g.P("// Send initial registration")
	g.P("if err := b.sendRegistration(); err != nil {")
	g.P(`return fmt.Errorf("failed to send registration: %v", err)`)
	g.P("}")
	g.P()
	g.P("// Start background goroutines")
	g.P("go b.handleHeartbeats()")
	g.P("go b.handleRegistrationResponses()")
	g.P()
	g.P("return nil")
	g.P("}")
	g.P()

	// Send registration method
	g.P("// sendRegistration sends the initial registration message")
	g.P("func (b *", bridgeName, ") sendRegistration() error {")
	g.P("req := &", serviceName, "RegisterRequest{")
	g.P("Request: &", serviceName, "RegisterRequest_InstanceInfo{")
	g.P("InstanceInfo: &pb.InstanceInfo{")
	g.P("InstanceId:   b.options.InstanceID,")
	g.P(`ServiceName:  "`, serviceName, `",`)
	g.P("Endpoint:     b.options.Endpoint,")
	g.P("Metadata:     b.options.Metadata,")
	g.P("HealthStatus: pb.HealthStatus_HEALTHY,")
	g.P("RegisteredAt: timestamppb.Now(),")
	g.P("},")
	g.P("},")
	g.P("}")
	g.P()
	g.P("return b.stream.Send(req)")
	g.P("}")
	g.P()

	// Heartbeat handling
	g.P("// handleHeartbeats sends periodic heartbeat messages")
	g.P("func (b *", bridgeName, ") handleHeartbeats() {")
	g.P("ticker := time.NewTicker(b.options.HeartbeatInterval)")
	g.P("defer ticker.Stop()")
	g.P()
	g.P("for {")
	g.P("select {")
	g.P("case <-ticker.C:")
	g.P("heartbeat := &", serviceName, "RegisterRequest{")
	g.P("Request: &", serviceName, "RegisterRequest_Heartbeat{")
	g.P("Heartbeat: &pb.Heartbeat{")
	g.P("InstanceId:   b.options.InstanceID,")
	g.P("Timestamp:    timestamppb.Now(),")
	g.P("HealthStatus: pb.HealthStatus_HEALTHY,")
	g.P("},")
	g.P("},")
	g.P("}")
	g.P()
	g.P("if err := b.stream.Send(heartbeat); err != nil {")
	g.P(`log.Printf("[%s] Failed to send heartbeat: %v", b.options.InstanceID, err)`)
	g.P("return")
	g.P("}")
	g.P()
	g.P("case <-b.ctx.Done():")
	g.P("return")
	g.P("}")
	g.P("}")
	g.P("}")
	g.P()

	// Registration response handling
	g.P("// handleRegistrationResponses processes messages from the router")
	g.P("func (b *", bridgeName, ") handleRegistrationResponses() {")
	g.P("for {")
	g.P("select {")
	g.P("case <-b.ctx.Done():")
	g.P("return")
	g.P("default:")
	g.P("}")
	g.P()
	g.P("resp, err := b.stream.Recv()")
	g.P("if err != nil {")
	g.P(`log.Printf("[%s] Registration stream error: %v", b.options.InstanceID, err)`)
	g.P("return")
	g.P("}")
	g.P()
	g.P("switch msg := resp.Response.(type) {")
	g.P("case *", serviceName, "RegisterResponse_Ack:")
	g.P("if msg.Ack.Success {")
	g.P(`log.Printf("[%s] Registration acknowledged: %s", b.options.InstanceID, msg.Ack.Message)`)
	g.P("} else {")
	g.P(`log.Printf("[%s] Registration failed: %s", b.options.InstanceID, msg.Ack.Message)`)
	g.P("}")
	g.P()
	g.P("case *", serviceName, "RegisterResponse_RpcCall:")
	g.P("// Handle incoming RPC call")
	g.P("go b.handleRPCCall(msg.RpcCall)")
	g.P()
	g.P("case *", serviceName, "RegisterResponse_Error:")
	g.P(`log.Printf("[%s] Router error: %s", b.options.InstanceID, msg.Error.Message)`)
	g.P()
	g.P("default:")
	g.P(`log.Printf("[%s] Unknown response type", b.options.InstanceID)`)
	g.P("}")
	g.P("}")
	g.P("}")
	g.P()

	return nil
}

// generateRPCDispatch generates the RPC call handling and dispatch logic
func generateRPCDispatch(g *protogen.GeneratedFile, service *protogen.Service, serviceName, bridgeName string) error {
	// Main RPC handler
	g.P("// handleRPCCall processes incoming RPC calls and dispatches to service methods")
	g.P("func (b *", bridgeName, ") handleRPCCall(rpcCall *", serviceName, "RpcCall) {")
	g.P(`log.Printf("[%s] Handling RPC call: %s (ID: %s)", b.options.InstanceID, rpcCall.Method, rpcCall.RequestId)`)
	g.P()
	g.P("var response *", serviceName, "RpcResponse")
	g.P()
	g.P("// Dispatch based on typed request oneof")
	g.P("switch req := rpcCall.Request.(type) {")

	// Generate cases for each service method
	for _, method := range service.Methods {
		methodName := method.GoName
		g.P("case *", serviceName, "RpcCall_", methodName, ":")
		g.P("response = b.handle", methodName, "(rpcCall.RequestId, req.", methodName, ")")
		g.P()
	}

	g.P("default:")
	g.P(`log.Printf("[%s] Unknown method in RPC call", b.options.InstanceID)`)
	g.P("response = &", serviceName, "RpcResponse{")
	g.P("RequestId: rpcCall.RequestId,")
	g.P("Status: &pb.RpcStatus{")
	g.P("Code:    12, // UNIMPLEMENTED")
	g.P(`Message: "Method not implemented",`)
	g.P("},")
	g.P("Metadata: make(map[string]string),")
	g.P("}")
	g.P("}")
	g.P()
	g.P("// Send response")
	g.P("b.sendResponse(response)")
	g.P("}")
	g.P()

	// Generate individual method handlers
	for _, method := range service.Methods {
		if err := generateMethodHandler(g, method, serviceName, bridgeName); err != nil {
			return err
		}
	}

	// Send response method
	g.P("// sendResponse sends a typed response back to the router")
	g.P("func (b *", bridgeName, ") sendResponse(response *", serviceName, "RpcResponse) {")
	g.P("req := &", serviceName, "RegisterRequest{")
	g.P("Request: &", serviceName, "RegisterRequest_RpcResponse{")
	g.P("RpcResponse: response,")
	g.P("},")
	g.P("}")
	g.P()
	g.P("if err := b.stream.Send(req); err != nil {")
	g.P(`log.Printf("[%s] Failed to send response: %v", b.options.InstanceID, err)`)
	g.P("}")
	g.P("}")
	g.P()

	return nil
}

// generateMethodHandler generates a handler for a specific service method
func generateMethodHandler(g *protogen.GeneratedFile, method *protogen.Method, serviceName, bridgeName string) error {
	methodName := method.GoName
	
	// Only implement unary methods for now, others are TODO
	if method.Desc.IsStreamingClient() || method.Desc.IsStreamingServer() {
		// Generate stub for streaming methods
		g.P("// handle", methodName, " handles ", methodName, " RPC calls (streaming - not yet implemented)")
		g.P("func (b *", bridgeName, ") handle", methodName, "(requestID string, req *", method.Input.GoIdent.GoName, ") *", serviceName, "RpcResponse {")
		g.P(`log.Printf("[%s] `, methodName, ` (streaming) not yet implemented", b.options.InstanceID)`)
		g.P("return &", serviceName, "RpcResponse{")
		g.P("RequestId: requestID,")
		g.P("Status: &pb.RpcStatus{")
		g.P("Code:    12, // UNIMPLEMENTED")
		g.P(`Message: "Streaming methods not yet implemented",`)
		g.P("},")
		g.P("Metadata: make(map[string]string),")
		g.P("}")
		g.P("}")
		g.P()
		return nil
	}

	// Generate unary method handler
	g.P("// handle", methodName, " handles ", methodName, " RPC calls")
	g.P("func (b *", bridgeName, ") handle", methodName, "(requestID string, req *", method.Input.GoIdent.GoName, ") *", serviceName, "RpcResponse {")
	g.P(`log.Printf("[%s] Processing `, methodName, ` request", b.options.InstanceID)`)
	g.P()
	g.P("// Call the service method")
	g.P("ctx := context.Background()")
	g.P("resp, err := b.service.", methodName, "(ctx, req)")
	g.P()
	g.P("if err != nil {")
	g.P(`log.Printf("[%s] `, methodName, ` call failed: %v", b.options.InstanceID, err)`)
	g.P("return &", serviceName, "RpcResponse{")
	g.P("RequestId: requestID,")
	g.P("Status: &pb.RpcStatus{")
	g.P("Code:    13, // INTERNAL")
	g.P(`Message: fmt.Sprintf("Service method failed: %v", err),`)
	g.P("},")
	g.P("Metadata: make(map[string]string),")
	g.P("}")
	g.P("}")
	g.P()
	g.P(`log.Printf("[%s] `, methodName, ` completed successfully", b.options.InstanceID)`)
	g.P("return &", serviceName, "RpcResponse{")
	g.P("RequestId: requestID,")
	g.P("Status: &pb.RpcStatus{")
	g.P("Code:    0, // OK")
	g.P(`Message: "Success",`)
	g.P("},")
	g.P("Metadata: make(map[string]string),")
	g.P("Response: &", serviceName, "RpcResponse_", methodName, "{", methodName, ": resp},")
	g.P("}")
	g.P("}")
	g.P()

	return nil
}