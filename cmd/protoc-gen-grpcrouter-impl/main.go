package main

import (
	"fmt"
	"log"
	"strings"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	protogen.Options{}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			// Only process generated router proto files
			if !isGeneratedRouterProto(f) {
				continue
			}

			// Generate router implementation for this router proto
			if err := generateRouterImplementation(gen, f); err != nil {
				return fmt.Errorf("failed to generate router implementation for %s: %v", f.Desc.Path(), err)
			}
		}

		return nil
	})
}

// isGeneratedRouterProto checks if this is a generated router proto file
func isGeneratedRouterProto(f *protogen.File) bool {
	// Check if filename contains "_router" and has router services
	if !strings.Contains(string(f.Desc.Path()), "_router") {
		return false
	}

	// Check if it has services ending with "Router"
	for _, service := range f.Services {
		if strings.HasSuffix(service.GoName, "Router") {
			return true
		}
	}
	
	return false
}

// generateRouterImplementation generates the router implementation
func generateRouterImplementation(gen *protogen.Plugin, f *protogen.File) error {
	// Find the router service
	var routerService *protogen.Service
	for _, service := range f.Services {
		if strings.HasSuffix(service.GoName, "Router") {
			routerService = service
			break
		}
	}

	if routerService == nil {
		return fmt.Errorf("no router service found in file %s", f.Desc.Path())
	}

	// Create output filename
	baseFileName := strings.TrimSuffix(string(f.Desc.Path()), ".proto")
	outputPath := baseFileName + "_impl.pb.go"

	// Generate the implementation file
	genFile := gen.NewGeneratedFile(outputPath, f.GoImportPath)
	
	if err := generateImplementationContent(genFile, f, routerService); err != nil {
		return fmt.Errorf("failed to generate implementation content: %v", err)
	}

	log.Printf("Generated router implementation: %s", outputPath)
	return nil
}

// generateImplementationContent generates the router implementation content
func generateImplementationContent(g *protogen.GeneratedFile, f *protogen.File, routerService *protogen.Service) error {
	serviceName := strings.TrimSuffix(routerService.GoName, "Router")
	implName := routerService.GoName + "Impl"

	// Package and imports
	g.P("// Code generated by protoc-gen-grpcrouter-impl. DO NOT EDIT.")
	g.P("// source: ", f.Desc.Path())
	g.P()
	g.P("package ", f.GoPackageName)
	g.P()
	g.P("import (")
	g.P(`"context"`)
	g.P(`"log"`)
	g.P(`"strconv"`)
	g.P(`"sync"`) 
	g.P(`"time"`)
	g.P()
	g.P(`"google.golang.org/grpc/codes"`)
	g.P(`"google.golang.org/grpc/metadata"`)
	g.P(`"google.golang.org/grpc/status"`)
	g.P()
	g.P(`"github.com/panyam/grpcrouter/router"`)
	g.P(`pb "github.com/panyam/grpcrouter/proto/gen/go/grpcrouter/v1"`)
	g.P(")")
	g.P()

	// Generate the router implementation struct
	g.P("// ", implName, " implements ", routerService.GoName, "Server with routing capabilities")
	g.P("type ", implName, " struct {")
	g.P("Unimplemented", routerService.GoName, "Server")
	g.P()
	g.P("// Core routing components")
	g.P("correlator *router.RequestCorrelator")
	g.P("registry   *router.ServiceRegistry")
	g.P("config     *router.RouterConfig")
	g.P()
	g.P("// Service instance management")
	g.P("instances    map[string]*router.ServiceInstance")
	g.P("instancesMux sync.RWMutex")
	g.P("}")
	g.P()

	// Generate constructor
	g.P("// New", implName, " creates a new ", serviceName, " router")
	g.P("func New", implName, "(config *router.RouterConfig) *", implName, " {")
	g.P("if config == nil {")
	g.P("config = &router.RouterConfig{")
	g.P("DefaultTimeout:      30 * time.Second,")
	g.P("MaxConcurrentRPCs:   1000,")
	g.P("HealthCheckInterval: 30 * time.Second,")
	g.P("}")
	g.P("}")
	g.P("return &", implName, "{")
	g.P("correlator: router.NewRequestCorrelator(),")
	g.P("registry:   router.NewServiceRegistry(),")
	g.P("config:     config,")
	g.P("instances:  make(map[string]*router.ServiceInstance),")
	g.P("}")
	g.P("}")
	g.P()

	// Generate proxy methods for each service method
	for _, method := range routerService.Methods {
		if method.GoName == "Register" {
			// Skip Register - we'll handle it separately
			continue
		}
		
		if err := generateProxyMethod(g, serviceName, method); err != nil {
			return fmt.Errorf("failed to generate proxy method %s: %v", method.GoName, err)
		}
	}

	// Generate Register method
	if err := generateRegisterMethod(g, serviceName, implName); err != nil {
		return fmt.Errorf("failed to generate Register method: %v", err)
	}

	// Generate helper methods
	if err := generateHelperMethods(g, serviceName, implName); err != nil {
		return fmt.Errorf("failed to generate helper methods: %v", err)
	}

	return nil
}

// generateProxyMethod generates a proxy method that routes calls to service instances
func generateProxyMethod(g *protogen.GeneratedFile, serviceName string, method *protogen.Method) error {
	methodName := method.GoName
	
	if method.Desc.IsStreamingClient() && method.Desc.IsStreamingServer() {
		// Bidirectional streaming
		g.P("// ", methodName, " implements the ", methodName, " method with routing")
		g.P("func (r *", serviceName, "RouterImpl) ", methodName, "(stream ", serviceName, "Router_", methodName, "Server) error {")
		g.P("// TODO: Implement bidirectional streaming routing")
		g.P(`return status.Errorf(codes.Unimplemented, "bidirectional streaming not yet implemented")`)
		g.P("}")
		g.P()
	} else if method.Desc.IsStreamingClient() {
		// Client streaming
		g.P("// ", methodName, " implements the ", methodName, " method with routing")
		g.P("func (r *", serviceName, "RouterImpl) ", methodName, "(stream ", serviceName, "Router_", methodName, "Server) error {")
		g.P("// TODO: Implement client streaming routing")
		g.P(`return status.Errorf(codes.Unimplemented, "client streaming not yet implemented")`)
		g.P("}")
		g.P()
	} else if method.Desc.IsStreamingServer() {
		// Server streaming  
		g.P("// ", methodName, " implements the ", methodName, " method with routing")
		g.P("func (r *", serviceName, "RouterImpl) ", methodName, "(req *", method.Input.GoIdent.GoName, ", stream ", serviceName, "Router_", methodName, "Server) error {")
		g.P("// TODO: Implement server streaming routing")
		g.P(`return status.Errorf(codes.Unimplemented, "server streaming not yet implemented")`)
		g.P("}")
		g.P()
	} else {
		// Unary RPC
		g.P("// ", methodName, " implements the ", methodName, " method with routing")
		g.P("func (r *", serviceName, "RouterImpl) ", methodName, "(ctx context.Context, req *", method.Input.GoIdent.GoName, ") (*", method.Output.GoIdent.GoName, ", error) {")
		g.P("// Extract routing key from metadata or request")
		g.P("routingKey := r.extractRoutingKey(ctx, req)")
		g.P()
		g.P("// Find appropriate instance")
		g.P(`instance, err := r.registry.SelectInstance("`, serviceName, `", routingKey)`)
		g.P("if err != nil {")
		g.P(`return nil, status.Errorf(codes.Unavailable, "no available instance for service `, serviceName, `: %v", err)`)
		g.P("}")
		g.P()
		g.P("// Create typed RPC call")
		g.P("call := &", serviceName, "RpcCall{")
		g.P(`RequestId:  "req-" + strconv.FormatInt(time.Now().UnixNano(), 10),`)
		g.P(`Method:     "/`, serviceName, "/", methodName, `",`)
		g.P("MethodType: pb.RpcMethodType_UNARY,")
		g.P("Metadata:   make(map[string]string),")
		g.P("Request:    &", serviceName, "RpcCall_", methodName, "{", methodName, ": req},")
		g.P("}")
		g.P()
		g.P("// Send typed call to instance and wait for typed response")
		g.P("response, err := r.sendTypedCall(instance, call)")
		g.P("if err != nil {")
		g.P("return nil, err")
		g.P("}")
		g.P()
		g.P("// Extract typed response")
		g.P("if resp := response.Get", methodName, "(); resp != nil {")
		g.P("return resp, nil")
		g.P("}")
		g.P()
		g.P(`return nil, status.Errorf(codes.Internal, "invalid response type for `, methodName, `")`)
		g.P("}")
		g.P()
	}

	return nil
}

// generateRegisterMethod generates the Register method implementation
func generateRegisterMethod(g *protogen.GeneratedFile, serviceName, implName string) error {
	g.P("// Register handles service instance registration with typed messages")
	g.P("func (r *", implName, ") Register(stream ", serviceName, "Router_RegisterServer) error {")
	g.P("// Wait for initial registration message")
	g.P("req, err := stream.Recv()")
	g.P("if err != nil {")
	g.P(`return status.Errorf(codes.Internal, "failed to receive registration: %v", err)`)
	g.P("}")
	g.P()
	g.P("// Extract instance info")
	g.P("instanceInfo := req.GetInstanceInfo()")
	g.P("if instanceInfo == nil {")
	g.P(`return status.Errorf(codes.InvalidArgument, "expected instance info in first message")`)
	g.P("}")
	g.P()
	g.P("// Validate service name")
	g.P(`if instanceInfo.ServiceName != "`, serviceName, `" {`)
	g.P(`return status.Errorf(codes.InvalidArgument, "service name mismatch: expected `, serviceName, `, got %s", instanceInfo.ServiceName)`)
	g.P("}")
	g.P()
	g.P("// Create service instance")
	g.P("instance := &router.ServiceInstance{")
	g.P("InstanceID:    instanceInfo.InstanceId,")
	g.P(`ServiceName:   "`, serviceName, `",`)
	g.P("Endpoint:      instanceInfo.Endpoint,")
	g.P("Metadata:      instanceInfo.Metadata,")
	g.P("HealthStatus:  instanceInfo.HealthStatus,")
	g.P("RegisteredAt:  time.Now(),")
	g.P("LastHeartbeat: time.Now(),")
	g.P("RequestQueue:  make(chan *pb.RpcCall, 100),")
	g.P("ResponseQueue: make(chan *pb.RpcResponse, 100),")
	g.P("Connected:     true,")
	g.P("}")
	g.P()
	g.P("// Register instance")
	g.P("r.instancesMux.Lock()")
	g.P("r.instances[instanceInfo.InstanceId] = instance")
	g.P("r.instancesMux.Unlock()")
	g.P()
	g.P("if err := r.registry.RegisterInstance(instance); err != nil {")
	g.P("r.instancesMux.Lock()")
	g.P("delete(r.instances, instanceInfo.InstanceId)")
	g.P("r.instancesMux.Unlock()")
	g.P(`return status.Errorf(codes.AlreadyExists, "failed to register instance: %v", err)`)
	g.P("}")
	g.P()
	g.P("// Send registration acknowledgment")
	g.P("ack := &", serviceName, "RegisterResponse{")
	g.P("Response: &", serviceName, "RegisterResponse_Ack{")
	g.P("Ack: &pb.RegistrationAck{")
	g.P("InstanceId: instanceInfo.InstanceId,")
	g.P("Success:    true,")
	g.P(`Message:    "Registration successful",`)
	g.P("},")
	g.P("},")
	g.P("}")
	g.P()
	g.P("if err := stream.Send(ack); err != nil {")
	g.P("r.unregisterInstance(instanceInfo.InstanceId)")
	g.P(`return status.Errorf(codes.Internal, "failed to send acknowledgment: %v", err)`)
	g.P("}")
	g.P()
	g.P(`log.Printf("Service instance registered: %s (`, serviceName, `)", instanceInfo.InstanceId)`)
	g.P()
	g.P("// Start instance handling goroutines")
	g.P("go r.handleInstanceRequests(instance)")
	g.P("go r.handleInstanceResponses(instance)")
	g.P()
	g.P("// Handle incoming messages from the instance")
	g.P("return r.handleInstanceMessages(instance)")
	g.P("}")
	g.P()

	return nil
}

// generateHelperMethods generates helper methods for the router implementation
func generateHelperMethods(g *protogen.GeneratedFile, serviceName, implName string) error {
	// extractRoutingKey method
	g.P("// extractRoutingKey extracts the routing key from context or request")
	g.P("func (r *", implName, ") extractRoutingKey(ctx context.Context, req interface{}) string {")
	g.P("// TODO: Implement routing key extraction based on routing strategy")
	g.P("// For now, extract from gRPC metadata")
	g.P(`if md, ok := metadata.FromIncomingContext(ctx); ok {`)
	g.P(`if values := md.Get("instanceid"); len(values) > 0 {`)
	g.P("return values[0]")
	g.P("}")
	g.P("}")
	g.P(`return ""`)
	g.P("}")
	g.P()

	// sendTypedCall method
	g.P("// sendTypedCall sends a typed RPC call to an instance and waits for typed response")
	g.P("func (r *", implName, ") sendTypedCall(instance *router.ServiceInstance, call *", serviceName, "RpcCall) (*", serviceName, "RpcResponse, error) {")
	g.P("// TODO: Implement typed call sending and response correlation")
	g.P("// This would send the typed call through the registration stream")
	g.P("// and wait for the typed response using request correlation")
	g.P(`return nil, status.Errorf(codes.Unimplemented, "typed call routing not yet implemented")`)
	g.P("}")
	g.P()

	// Instance management methods
	g.P("// unregisterInstance removes an instance from the router")
	g.P("func (r *", implName, ") unregisterInstance(instanceID string) {")
	g.P("r.instancesMux.Lock()")
	g.P("delete(r.instances, instanceID)")
	g.P("r.instancesMux.Unlock()")
	g.P("r.registry.UnregisterInstance(instanceID)")
	g.P("}")
	g.P()

	g.P("// handleInstanceMessages processes incoming messages from a service instance")
	g.P("func (r *", implName, ") handleInstanceMessages(instance *router.ServiceInstance) error {")
	g.P("// TODO: Implement instance message handling with typed oneof")
	g.P(`return status.Errorf(codes.Unimplemented, "instance message handling not yet implemented")`)
	g.P("}")
	g.P()

	g.P("// handleInstanceRequests sends RPC requests to the service instance") 
	g.P("func (r *", implName, ") handleInstanceRequests(instance *router.ServiceInstance) {")
	g.P("// TODO: Implement instance request handling")
	g.P("}")
	g.P()

	g.P("// handleInstanceResponses processes RPC responses from the service instance")
	g.P("func (r *", implName, ") handleInstanceResponses(instance *router.ServiceInstance) {")
	g.P("// TODO: Implement instance response handling")
	g.P("}")
	g.P()

	return nil
}