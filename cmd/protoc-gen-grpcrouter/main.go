package main

import (
	"flag"
	"fmt"

	"google.golang.org/protobuf/compiler/protogen"
	"google.golang.org/protobuf/types/pluginpb"
)

func main() {
	var flags flag.FlagSet

	protogen.Options{
		ParamFunc: flags.Set,
	}.Run(func(gen *protogen.Plugin) error {
		gen.SupportedFeatures = uint64(pluginpb.CodeGeneratorResponse_FEATURE_PROTO3_OPTIONAL)

		for _, f := range gen.Files {
			if !f.Generate {
				continue
			}

			if err := generateFile(gen, f); err != nil {
				return err
			}
		}

		return nil
	})
}

func generateFile(gen *protogen.Plugin, file *protogen.File) error {
	// Check if file has services with routing annotations
	hasRoutedServices := false
	for _, service := range file.Services {
		if hasRoutingAnnotation(service) {
			hasRoutedServices = true
			break
		}
	}

	if !hasRoutedServices {
		return nil
	}

	// Generate router file
	filename := file.GeneratedFilenamePrefix + "_router.pb.go"
	g := gen.NewGeneratedFile(filename, file.GoImportPath)

	// Generate file header
	generateHeader(g, file)

	// Generate router for each service
	for _, service := range file.Services {
		if hasRoutingAnnotation(service) {
			if err := generateServiceRouter(g, service); err != nil {
				return fmt.Errorf("failed to generate router for service %s: %w", service.GoName, err)
			}
		}
	}

	return nil
}

func generateHeader(g *protogen.GeneratedFile, file *protogen.File) {
	g.P("// Code generated by protoc-gen-grpcrouter. DO NOT EDIT.")
	g.P("// source: ", file.Desc.Path())
	g.P()
	g.P("package ", file.GoPackageName)
	g.P()
	g.P("import (")
	g.P("  \"context\"")
	g.P("  \"io\"")
	g.P("  \"log\"")
	g.P("  \"time\"")
	g.P()
	g.P("  \"google.golang.org/grpc/codes\"")
	g.P("  \"google.golang.org/grpc/metadata\"")
	g.P("  \"google.golang.org/grpc/status\"")
	g.P("  \"google.golang.org/protobuf/types/known/anypb\"")
	g.P()
	g.P("  \"github.com/panyam/grpcrouter/router\"")
	g.P("  pb \"github.com/panyam/grpcrouter/proto/gen/go/grpcrouter/v1\"")
	g.P(")")
	g.P()
}

func generateServiceRouter(g *protogen.GeneratedFile, service *protogen.Service) error {
	serviceName := service.GoName
	routerName := serviceName + "Router"

	// Generate router struct
	g.P("// ", routerName, " implements ", serviceName, " interface with routing capabilities")
	g.P("type ", routerName, " struct {")
	g.P("  Unimplemented", serviceName, "Server")
	g.P("  correlator *router.RequestCorrelator")
	g.P("  registry   *router.ServiceRegistry")
	g.P("  config     *router.RouterConfig")
	g.P("  routerServer *router.RouterServer")
	g.P("}")
	g.P()

	// Generate constructor
	g.P("// New", routerName, " creates a new ", serviceName, " router")
	g.P("func New", routerName, "(config *router.RouterConfig) *", routerName, " {")
	g.P("  if config == nil {")
	g.P("    config = &router.RouterConfig{")
	g.P("      DefaultTimeout: 30 * time.Second,")
	g.P("      MaxConcurrentRPCs: 1000,")
	g.P("      HealthCheckInterval: 30 * time.Second,")
	g.P("    }")
	g.P("  }")
	g.P("  routerServer := router.NewRouterServer(config)")
	g.P("  return &", routerName, "{")
	g.P("    correlator: router.NewRequestCorrelator(),")
	g.P("    registry:   router.NewServiceRegistry(),")
	g.P("    config:     config,")
	g.P("    routerServer: routerServer,")
	g.P("  }")
	g.P("}")
	g.P()

	// Generate Register method for service instances
	g.P("// Register handles service instance registration")
	g.P("func (r *", routerName, ") Register(stream pb.Router_RegisterServer) error {")
	g.P("  // Use the shared router server logic")
	g.P("  return r.routerServer.Register(stream)")
	g.P("}")
	g.P()

	// Generate method implementations
	for _, method := range service.Methods {
		if err := generateMethodHandler(g, serviceName, routerName, method); err != nil {
			return err
		}
	}

	// Generate helper methods
	generateHelperMethods(g, serviceName, routerName)

	return nil
}

func generateMethodHandler(g *protogen.GeneratedFile, serviceName, routerName string, method *protogen.Method) error {
	methodName := method.GoName
	inputType := method.Input.GoIdent.GoName
	outputType := method.Output.GoIdent.GoName

	// Determine method type
	clientStreaming := method.Desc.IsStreamingClient()
	serverStreaming := method.Desc.IsStreamingServer()

	var methodType string
	switch {
	case !clientStreaming && !serverStreaming:
		methodType = "pb.RpcMethodType_UNARY"
	case !clientStreaming && serverStreaming:
		methodType = "pb.RpcMethodType_SERVER_STREAMING"
	case clientStreaming && !serverStreaming:
		methodType = "pb.RpcMethodType_CLIENT_STREAMING"
	case clientStreaming && serverStreaming:
		methodType = "pb.RpcMethodType_BIDIRECTIONAL_STREAMING"
	}

	// Generate method implementation based on type
	switch {
	case !clientStreaming && !serverStreaming:
		// Unary RPC
		g.P("// ", methodName, " implements the ", methodName, " method with routing")
		g.P("func (r *", routerName, ") ", methodName, "(ctx context.Context, req *", inputType, ") (*", outputType, ", error) {")
		g.P("  // Extract routing key from metadata or request")
		g.P("  routingKey := r.extractRoutingKey(ctx, req)")
		g.P("  ")
		g.P("  // Convert request to Any")
		g.P("  reqAny, err := anypb.New(req)")
		g.P("  if err != nil {")
		g.P("    return nil, status.Errorf(codes.Internal, \"failed to marshal request: %v\", err)")
		g.P("  }")
		g.P("  ")
		g.P("  // Route the call")
		g.P("  call, err := r.routeRPC(ctx, \"", serviceName, "\", \"/", serviceName, "/", methodName, "\", ", methodType, ", reqAny, routingKey)")
		g.P("  if err != nil {")
		g.P("    return nil, err")
		g.P("  }")
		g.P("  ")
		g.P("  // Wait for response")
		g.P("  select {")
		g.P("  case respAny := <-call.ResponseChan:")
		g.P("    var resp ", outputType)
		g.P("    if err := respAny.UnmarshalTo(&resp); err != nil {")
		g.P("      return nil, status.Errorf(codes.Internal, \"failed to unmarshal response: %v\", err)")
		g.P("    }")
		g.P("    return &resp, nil")
		g.P("  case err := <-call.ErrorChan:")
		g.P("    return nil, err")
		g.P("  case <-call.Context.Done():")
		g.P("    return nil, call.Context.Err()")
		g.P("  }")
		g.P("}")
		g.P()

	case !clientStreaming && serverStreaming:
		// Server streaming RPC
		g.P("// ", methodName, " implements the ", methodName, " method with routing")
		g.P("func (r *", routerName, ") ", methodName, "(req *", inputType, ", stream ", serviceName, "_", methodName, "Server) error {")
		g.P("  // Extract routing key")
		g.P("  routingKey := r.extractRoutingKey(stream.Context(), req)")
		g.P("  ")
		g.P("  // Convert request to Any")
		g.P("  reqAny, err := anypb.New(req)")
		g.P("  if err != nil {")
		g.P("    return status.Errorf(codes.Internal, \"failed to marshal request: %v\", err)")
		g.P("  }")
		g.P("  ")
		g.P("  // Route the call")
		g.P("  call, err := r.routeRPC(stream.Context(), \"", serviceName, "\", \"/", serviceName, "/", methodName, "\", ", methodType, ", reqAny, routingKey)")
		g.P("  if err != nil {")
		g.P("    return err")
		g.P("  }")
		g.P("  ")
		g.P("  // Stream responses back to client")
		g.P("  for {")
		g.P("    select {")
		g.P("    case streamMsg := <-call.StreamChan:")
		g.P("      if streamMsg == nil {")
		g.P("        return nil // Stream closed")
		g.P("      }")
		g.P("      var resp ", outputType)
		g.P("      if err := streamMsg.Message.UnmarshalTo(&resp); err != nil {")
		g.P("        return status.Errorf(codes.Internal, \"failed to unmarshal response: %v\", err)")
		g.P("      }")
		g.P("      if err := stream.Send(&resp); err != nil {")
		g.P("        return err")
		g.P("      }")
		g.P("    case err := <-call.ErrorChan:")
		g.P("      return err")
		g.P("    case <-call.Context.Done():")
		g.P("      return call.Context.Err()")
		g.P("    }")
		g.P("  }")
		g.P("}")
		g.P()

	case clientStreaming && !serverStreaming:
		// Client streaming RPC
		g.P("// ", methodName, " implements the ", methodName, " method with routing")
		g.P("func (r *", routerName, ") ", methodName, "(stream ", serviceName, "_", methodName, "Server) error {")
		g.P("  // Read first message to establish routing")
		g.P("  firstMsg, err := stream.Recv()")
		g.P("  if err != nil {")
		g.P("    return err")
		g.P("  }")
		g.P("  ")
		g.P("  // Extract routing key")
		g.P("  routingKey := r.extractRoutingKey(stream.Context(), firstMsg)")
		g.P("  ")
		g.P("  // Convert first message to Any")
		g.P("  firstAny, err := anypb.New(firstMsg)")
		g.P("  if err != nil {")
		g.P("    return status.Errorf(codes.Internal, \"failed to marshal request: %v\", err)")
		g.P("  }")
		g.P("  ")
		g.P("  // Route the call")
		g.P("  call, err := r.routeRPC(stream.Context(), \"", serviceName, "\", \"/", serviceName, "/", methodName, "\", ", methodType, ", firstAny, routingKey)")
		g.P("  if err != nil {")
		g.P("    return err")
		g.P("  }")
		g.P("  ")
		g.P("  // Stream remaining messages")
		g.P("  go func() {")
		g.P("    defer r.sendStreamControl(call.RequestID, pb.StreamControl_HALF_CLOSE)")
		g.P("    for {")
		g.P("      msg, err := stream.Recv()")
		g.P("      if err == io.EOF {")
		g.P("        return")
		g.P("      }")
		g.P("      if err != nil {")
		g.P("        log.Printf(\"Stream receive error: %v\", err)")
		g.P("        return")
		g.P("      }")
		g.P("      ")
		g.P("      msgAny, err := anypb.New(msg)")
		g.P("      if err != nil {")
		g.P("        log.Printf(\"Failed to marshal stream message: %v\", err)")
		g.P("        return")
		g.P("      }")
		g.P("      ")
		g.P("      if err := r.sendStreamMessage(call.RequestID, msgAny, pb.StreamControl_MESSAGE); err != nil {")
		g.P("        log.Printf(\"Failed to send stream message: %v\", err)")
		g.P("        return")
		g.P("      }")
		g.P("    }")
		g.P("  }()")
		g.P("  ")
		g.P("  // Wait for final response")
		g.P("  select {")
		g.P("  case respAny := <-call.ResponseChan:")
		g.P("    var resp ", outputType)
		g.P("    if err := respAny.UnmarshalTo(&resp); err != nil {")
		g.P("      return status.Errorf(codes.Internal, \"failed to unmarshal response: %v\", err)")
		g.P("    }")
		g.P("    return stream.SendAndClose(&resp)")
		g.P("  case err := <-call.ErrorChan:")
		g.P("    return err")
		g.P("  case <-call.Context.Done():")
		g.P("    return call.Context.Err()")
		g.P("  }")
		g.P("}")
		g.P()

	case clientStreaming && serverStreaming:
		// Bidirectional streaming RPC
		g.P("// ", methodName, " implements the ", methodName, " method with routing")
		g.P("func (r *", routerName, ") ", methodName, "(stream ", serviceName, "_", methodName, "Server) error {")
		g.P("  // Read first message to establish routing")
		g.P("  firstMsg, err := stream.Recv()")
		g.P("  if err != nil {")
		g.P("    return err")
		g.P("  }")
		g.P("  ")
		g.P("  // Extract routing key")
		g.P("  routingKey := r.extractRoutingKey(stream.Context(), firstMsg)")
		g.P("  ")
		g.P("  // Convert first message to Any")
		g.P("  firstAny, err := anypb.New(firstMsg)")
		g.P("  if err != nil {")
		g.P("    return status.Errorf(codes.Internal, \"failed to marshal request: %v\", err)")
		g.P("  }")
		g.P("  ")
		g.P("  // Route the call")
		g.P("  call, err := r.routeRPC(stream.Context(), \"", serviceName, "\", \"/", serviceName, "/", methodName, "\", ", methodType, ", firstAny, routingKey)")
		g.P("  if err != nil {")
		g.P("    return err")
		g.P("  }")
		g.P("  ")
		g.P("  // Handle bidirectional streaming")
		g.P("  errChan := make(chan error, 2)")
		g.P("  ")
		g.P("  // Goroutine to handle client -> server streaming")
		g.P("  go func() {")
		g.P("    defer r.sendStreamControl(call.RequestID, pb.StreamControl_HALF_CLOSE)")
		g.P("    for {")
		g.P("      msg, err := stream.Recv()")
		g.P("      if err == io.EOF {")
		g.P("        errChan <- nil")
		g.P("        return")
		g.P("      }")
		g.P("      if err != nil {")
		g.P("        errChan <- err")
		g.P("        return")
		g.P("      }")
		g.P("      ")
		g.P("      msgAny, err := anypb.New(msg)")
		g.P("      if err != nil {")
		g.P("        errChan <- err")
		g.P("        return")
		g.P("      }")
		g.P("      ")
		g.P("      if err := r.sendStreamMessage(call.RequestID, msgAny, pb.StreamControl_MESSAGE); err != nil {")
		g.P("        errChan <- err")
		g.P("        return")
		g.P("      }")
		g.P("    }")
		g.P("  }()")
		g.P("  ")
		g.P("  // Goroutine to handle server -> client streaming")
		g.P("  go func() {")
		g.P("    for {")
		g.P("      select {")
		g.P("      case streamMsg := <-call.StreamChan:")
		g.P("        if streamMsg == nil {")
		g.P("          errChan <- nil")
		g.P("          return")
		g.P("        }")
		g.P("        var resp ", outputType)
		g.P("        if err := streamMsg.Message.UnmarshalTo(&resp); err != nil {")
		g.P("          errChan <- err")
		g.P("          return")
		g.P("        }")
		g.P("        if err := stream.Send(&resp); err != nil {")
		g.P("          errChan <- err")
		g.P("          return")
		g.P("        }")
		g.P("      case err := <-call.ErrorChan:")
		g.P("        errChan <- err")
		g.P("        return")
		g.P("      case <-call.Context.Done():")
		g.P("        errChan <- call.Context.Err()")
		g.P("        return")
		g.P("      }")
		g.P("    }")
		g.P("  }()")
		g.P("  ")
		g.P("  // Wait for completion")
		g.P("  return <-errChan")
		g.P("}")
		g.P()
	}

	return nil
}

func generateHelperMethods(g *protogen.GeneratedFile, serviceName, routerName string) {
	// Generate extractRoutingKey method
	g.P("// extractRoutingKey extracts the routing key from context or request")
	g.P("func (r *", routerName, ") extractRoutingKey(ctx context.Context, req interface{}) string {")
	g.P("  // TODO: Implement routing key extraction based on routing strategy")
	g.P("  // For now, extract from gRPC metadata")
	g.P("  if md, ok := metadata.FromIncomingContext(ctx); ok {")
	g.P("    if values := md.Get(\"instanceid\"); len(values) > 0 {")
	g.P("      return values[0]")
	g.P("    }")
	g.P("  }")
	g.P("  return \"\"")
	g.P("}")
	g.P()

	// Generate routeRPC method
	g.P("// routeRPC routes an RPC call to an appropriate service instance")
	g.P("func (r *", routerName, ") routeRPC(ctx context.Context, serviceName, method string, methodType pb.RpcMethodType, request *anypb.Any, routingKey string) (*router.PendingCall, error) {")
	g.P("  // Use the shared router server to handle the routing")
	g.P("  return r.routerServer.RouteRPC(ctx, serviceName, method, methodType, request, nil, routingKey)")
	g.P("}")
	g.P()

	// Generate sendStreamMessage method
	g.P("// sendStreamMessage sends a stream message for an active RPC call")
	g.P("func (r *", routerName, ") sendStreamMessage(requestID string, message *anypb.Any, control pb.StreamControl) error {")
	g.P("  return r.routerServer.SendStreamMessage(requestID, message, control)")
	g.P("}")
	g.P()

	// Generate sendStreamControl method
	g.P("// sendStreamControl sends a stream control signal")
	g.P("func (r *", routerName, ") sendStreamControl(requestID string, control pb.StreamControl) error {")
	g.P("  return r.sendStreamMessage(requestID, nil, control)")
	g.P("}")
	g.P()
}

func hasRoutingAnnotation(service *protogen.Service) bool {
	// For simplicity, exclude the Router service itself and include all others
	return service.GoName != "Router"
}
